TestCase subclass: #DateAndTimeEpochTest	instanceVariableNames: 'aDateAndTime aDuration aTimeZone localTimeZoneToRestore localTimeZonePreferenceToRestore'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!DateAndTimeEpochTest commentStamp: 'tlk 1/6/2004 18:27' prior: 0!I represent one of several Sunit test Cases intentended to provide complete coverage  for the Chronology set of classes as part of the external testing. The other Chronology sunit test cases are: DateTestCase DateAndTimeLeapTestCase, DurationTestCase, ScheduleTestCase TimeStampTestCase TimespanDoTestCase,  TimespanDoSpanAYearTestCase,  TimespanTestCase,  YearMonthWeekTestCase.  These tests attempt to exercise all public and private methods.  Except, they do not explicitly depreciated methods. tlkMy fixtures are:aDateAndTime = January 01, 1901 midnight (the start of the Squeak epoch) with localTimeZone = Grenwhich Meridian (local offset = 0 hours)aDuration = 1 day, 2 hours, 3, minutes, 4 seconds and 5 nano seconds.aTimeZone =  'Epoch Test Time Zone', 'ETZ' , offset: 12 hours, 15 minutes. !!DateAndTimeEpochTest methodsFor: 'running' stamp: 'dtl 12/4/2016 12:06'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	localTimeZonePreferenceToRestore := DateAndTime automaticTimezone.	aDateAndTime :=  DateAndTime localTimeZone: TimeZone default; epoch.	aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'Epoch Test Time Zone' abbreviation: 'ETZ'.	aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5 ! !!DateAndTimeEpochTest methodsFor: 'running' stamp: 'dtl 12/4/2016 12:07'!tearDown	DateAndTime localTimeZone: localTimeZoneToRestore.	DateAndTime automaticTimezone: localTimeZonePreferenceToRestore.     "wish I could remove the time zones I added earlier, tut there is no method for that"! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testAsDate	self assert: aDateAndTime asDate =   'January 1, 1901' asDate.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:31'!testAsDateAndTime	self assert: aDateAndTime asDateAndTime =  aDateAndTime	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:34'!testAsDuration	self assert: aDateAndTime asDuration =  0 asDuration	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:06'!testAsLocal	self assert: aDateAndTime asLocal =  aDateAndTime.	self assert: aDateAndTime asLocal = (aDateAndTime utcOffset: aDateAndTime class localOffset)	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:27'!testAsMonth	self assert: aDateAndTime asMonth = (Month month: 'January' year: 1901). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:59'!testAsNanoSeconds	self assert: aDateAndTime asNanoSeconds =  0 asDuration asNanoSeconds	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 14:01'!testAsSeconds	self assert: aDateAndTime asSeconds =  0 asDuration asSeconds	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:32'!testAsTime	self assert: aDateAndTime asTime =  Time midnight.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 14:51'!testAsTimeStamp	self assert: aDateAndTime asTimeStamp =  TimeStamp new.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:07'!testAsUTC	self assert: aDateAndTime asUTC =  aDateAndTime          ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:43'!testAsWeek	self assert: aDateAndTime asWeek = (Week starting: '12-31-1900' asDate). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:43'!testAsYear	self assert: aDateAndTime asYear =   (Year starting: '01-01-1901' asDate). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:28'!testCurrent	self deny: aDateAndTime =  (DateAndTime current).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:46'!testDateTime	self assert: aDateAndTime =  (DateAndTime date: '01-01-1901' asDate time: '00:00:00' asTime)! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testDay	self assert: aDateAndTime day =   DateAndTime new day! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:08'!testDayMonthYearDo	|iterations|	iterations := 0.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  iterations := iterations + 1])  = 1.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear])  = 1901.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth]) = 1.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay]) = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 15:45'!testDayOfMonth	self assert: aDateAndTime dayOfMonth  = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:47'!testDayOfWeek	self assert: aDateAndTime dayOfWeek  = 3.	self assert: aDateAndTime dayOfWeekAbbreviation = 'Tue'.	self assert: aDateAndTime dayOfWeekName = 'Tuesday'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testDayOfYear	self assert: aDateAndTime dayOfYear  = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysInMonth	self assert: aDateAndTime daysInMonth  = 31.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysInYear	self assert: aDateAndTime daysInYear  = 365.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysLeftInYear	self assert: aDateAndTime daysLeftInYear  = 364.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 16:24'!testDuration	self assert: aDateAndTime duration  = 0 asDuration.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:19'!testEpoch	self assert: aDateAndTime =  '1901-01-01T00:00:00+00:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:44'!testFirstDayOfMonth	self assert: aDateAndTime firstDayOfMonth =   1! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:25'!testFromSeconds	self assert: aDateAndTime =  (DateAndTime fromSeconds: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:26'!testFromString	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00').! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'pad 5/10/2012 17:13'!testHash	self assert: aDateAndTime hash =    DateAndTime new hash.	self assert: aDateAndTime hash =     112557138! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 16:59'!testHour	self assert: aDateAndTime hour =    aDateAndTime hour24.	self assert: aDateAndTime hour =    0.	self assert: aDateAndTime hour =    aDateAndTime hours! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'brp 3/12/2004 15:21'!testHour12	self assert: aDateAndTime hour12  = DateAndTime new hour12.	self assert: aDateAndTime hour12  = 12! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testIsLeapYear	self deny: aDateAndTime isLeapYear! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:18'!testJulianDayNumber	self assert: aDateAndTime =  (DateAndTime julianDayNumber: 2415386).	self assert: aDateAndTime julianDayNumber = 2415386.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:20'!testLessThan	self assert: aDateAndTime  < (aDateAndTime + '1:00:00:00').	self assert: aDateAndTime + -1 < aDateAndTime.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:40'!testMeridianAbbreviation	self assert: aDateAndTime meridianAbbreviation = 'AM'.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:37'!testMiddleOf	self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) = 	 (Timespan starting: '12-31-1900' asDate duration: 2 days).	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:39'!testMidnight	self assert: aDateAndTime midnight =  aDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:03'!testMinus	self assert: aDateAndTime - aDateAndTime =  '0:00:00:00' asDuration.	self assert: aDateAndTime - '0:00:00:00' asDuration = aDateAndTime.	self assert: aDateAndTime - aDuration =  (DateAndTime year: 1900 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours ).	" I believe this Failure is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)" ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:35'!testMinute	self assert: aDateAndTime minute =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:41'!testMinutes	self assert: aDateAndTime minutes = 0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:46'!testMonth	self assert: aDateAndTime month  = 1.	self assert: aDateAndTime monthAbbreviation = 'Jan'.	self assert: aDateAndTime monthName = 'January'.	self assert: aDateAndTime monthIndex = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:47'!testNanoSecond	self assert: aDateAndTime nanoSecond =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:27'!testNew	self assert: aDateAndTime =  (DateAndTime new).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:19'!testNoon	self assert: aDateAndTime noon = '1901-01-01T12:00:00+00:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:28'!testNow	self deny: aDateAndTime =  (DateAndTime now).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:20'!testOffset	self assert: aDateAndTime offset =  '0:00:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '1901-01-01T00:00:00+12:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 11:03'!testPlus	self assert: aDateAndTime + '0:00:00:00' = aDateAndTime.	self assert: aDateAndTime + 0 = aDateAndTime.	self assert: aDateAndTime + aDuration = (DateAndTime year: 1901 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours )	" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'nice 2/23/2013 20:23'!testPrintOn	| ref ws |	ref := '1901-01-01T00:00:00+00:00'.	ws := '' writeStream.	aDateAndTime printOn: ws.	self assert: ws contents = ref.	ref  := 'a TimeZone(ETZ)'.	ws := '' writeStream.	aTimeZone printOn:  ws.	self assert: ws contents = ref! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:22'!testSecond	self assert: aDateAndTime second =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:22'!testSeconds	self assert: aDateAndTime seconds =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:25'!testTicks	self assert: aDateAndTime ticks =  (DateAndTime julianDayNumber: 2415386) ticks.	self assert: aDateAndTime ticks = #(2415386 0 0)! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:31'!testTicksOffset	self assert: aDateAndTime =  (aDateAndTime ticks:  #(2415386 0 0) offset: DateAndTime localOffset).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:42'!testTo	self assert: (aDateAndTime to: aDateAndTime) = (DateAndTime new to: DateAndTime new) 	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:43'!testToBy	self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) = 				(DateAndTime new to: DateAndTime new + 10 days by: 5 days ) 	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:53'!testToByDo	"self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days do: []) =  "	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:35'!testToday	self deny: aDateAndTime =  (DateAndTime today).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:45'!testTommorrow	self assert: (DateAndTime today + 24 hours) =  (DateAndTime tomorrow).	self deny: aDateAndTime =  (DateAndTime tomorrow).     "MessageNotUnderstood: Date class>>starting:"! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:20'!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:12:00:00') =  '1901-01-01T12:00:00+12:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 21:00'!testYear	self assert: aDateAndTime year = 1901.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:30'!testYearDay	self assert: aDateAndTime =  (DateAndTime year: 1901 day: 1).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearDayHourMinuteSecond	self assert: aDateAndTime =  (DateAndTime year: 1901 day: 1 hour: 0 minute: 0 second: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearMonthDay	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearMonthDayHourMinuteSecond	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:23'!testYearMonthDayHourMinuteSecondNanosSecondOffset	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset:0 hours ).	self assert: ((DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours ) +				(Duration days: 1 hours: 2 minutes: 3 seconds: 4  nanoSeconds: 5) ) =  					(DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours ) 	" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"   ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:47'!testYesterday	self deny: aDateAndTime =  (DateAndTime yesterday).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'nk 3/12/2004 11:26'!testtimeZone	self assert: aDateAndTime timeZoneName	= 'Universal Time'.	self assert: aDateAndTime timeZoneAbbreviation	=  'UTC'! !TestCase subclass: #DateAndTimeLeapTest	instanceVariableNames: 'aDateAndTime aDuration aTimeZone localTimeZoneToRestore localTimeZonePreferenceToRestore'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!DateAndTimeLeapTest commentStamp: 'tlk 1/6/2004 17:54' prior: 0!I represent one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. tlk.My fixtures are:aDateAndTime = February 29, 2004 1:33 PM with offset: 2 hoursaDuration = 15 days, 14 hours, 13 minutes, 12 seconds and 11 nano seconds.aTimeZone =  Grenwhich Meridian (local offset = 0 hours) !!DateAndTimeLeapTest methodsFor: 'running' stamp: 'dtl 12/4/2016 12:08'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	localTimeZonePreferenceToRestore := DateAndTime automaticTimezone.	DateAndTime localTimeZone: TimeZone default.	aDateAndTime := (DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours).	aTimeZone := TimeZone default.	aDuration := Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0! !!DateAndTimeLeapTest methodsFor: 'running' stamp: 'dtl 12/4/2016 12:09'!tearDown     DateAndTime localTimeZone: localTimeZoneToRestore.	DateAndTime automaticTimezone: localTimeZonePreferenceToRestore.     "wish I could remove the time zones I added earlier, tut there is no method for that"! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 2/2/2012 21:48'!testAsDate	self assert: (aDateAndTime offset: DateAndTime localTimeZone offset) asDate = 'February 29, 2004' asDate! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:55'!testAsDuration	self assert: aDateAndTime asDuration =  aDuration	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:00'!testAsLocal	self assert: aDateAndTime asLocal =  aDateAndTime.	self assert: aDateAndTime asLocal = (aDateAndTime utcOffset: aDateAndTime class localOffset)	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 2/2/2012 22:51'!testAsMonth	self assert:		(aDateAndTime offset: Month defaultOffset) asMonth =			(Month				month: 'February'				year: 2004)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:59'!testAsNanoSeconds	self assert: aDateAndTime asNanoSeconds =  aDuration asNanoSeconds.	self assert: aDateAndTime asNanoSeconds = 48780000000000	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'dtl 12/3/2016 18:54'!testAsSeconds	self assert: aDuration asSeconds = 48780.	self assert: aDateAndTime asSeconds = 3255507180! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:26'!testAsTime	self assert: aDateAndTime asTime = (Time hour: 13 minute: 33 second: 0)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:31'!testAsTimeStamp	self assert: aDateAndTime asTimeStamp =  ((TimeStamp readFrom: '2-29-2004 1:33 pm' readStream) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:59'!testAsUTC	self assert: aDateAndTime asUTC =  aDateAndTime          ! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 2/2/2012 21:49'!testAsWeek	self assert: (aDateAndTime offset: DateAndTime localTimeZone offset) asWeek = (Week starting: '02-29-2004' asDate)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 2/2/2012 21:49'!testAsYear	| year |	year := (aDateAndTime offset: DateAndTime localTimeZone offset) asYear.	self assert: year = (Year starting: '02-29-2004' asDate).	self deny: year = (Year starting: '01-01-2004' asDate)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:23'!testDay	self assert: aDateAndTime day =   60. 	self deny: aDateAndTime day =   29 ! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 22:16'!testDayMonthYearDo	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear])  = 2004.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth]) = 2.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay]) = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 22:17'!testDayOfMonth	self assert: aDateAndTime dayOfMonth  = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:34'!testDayOfWeek	self assert: aDateAndTime dayOfWeek  = 1.	self assert: aDateAndTime dayOfWeekAbbreviation = 'Sun'.	self assert: aDateAndTime dayOfWeekName = 'Sunday'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:59'!testDayOfYear	self assert: aDateAndTime dayOfYear  = 60.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysInMonth	self assert: aDateAndTime daysInMonth  = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysInYear	self assert: aDateAndTime daysInYear  = 366.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysLeftInYear	self assert: aDateAndTime daysLeftInYear  = 306.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:38'!testFirstDayOfMonth	self deny: aDateAndTime firstDayOfMonth =  1.	self assert: aDateAndTime firstDayOfMonth = 32! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 10:43'!testFromString	self assert: aDateAndTime =  (DateAndTime fromString: ' 2004-02-29T13:33:00+02:00').! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'pad 5/10/2012 17:12'!testHash	self assert: aDateAndTime hash =      16256473! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 10:48'!testHour	self assert: aDateAndTime hour =    aDateAndTime hour24.	self assert: aDateAndTime hour =    13.	self assert: aDateAndTime hour =    aDateAndTime hours! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'brp 3/12/2004 15:19'!testHour12	self assert: aDateAndTime hour12  =   1.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:35'!testIsLeapYear	self assert: aDateAndTime isLeapYear! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testLessThan	self assert: aDateAndTime  < (aDateAndTime + '1:00:00:00').	self assert: aDateAndTime + -1 < aDateAndTime.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:42'!testMeridianAbbreviation	self assert: aDateAndTime meridianAbbreviation = 'PM'.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:12'!testMiddleOf	self assert: (aDateAndTime middleOf: aDuration)  = 	 (Timespan starting: (DateAndTime year: 2004 month: 2 day: 29 hour: 6 minute: 46 second: 30 offset: 2 hours)	duration: (Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0 ))	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 2/2/2012 21:51'!testMidnight	| midnight |	midnight := (aDateAndTime offset: DateAndTime localTimeZone offset) midnight.	self assert: midnight = '2004-02-29T00:00:00+00:00' asDateAndTime.	self deny: midnight = '2004-02-29T00:00:00+02:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:00'!testMinute	self assert: aDateAndTime minute =  33! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:44'!testMinutes	self assert: aDateAndTime minutes = 33! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:02'!testMonth	self assert: aDateAndTime month  = 2.	self assert: aDateAndTime monthAbbreviation = 'Feb'.	self assert: aDateAndTime monthName = 'February'.	self assert: aDateAndTime monthIndex = 2.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 4/28/2011 22:28'!testMonthParsing	self assert:		(Month readFrom: 'Feb 2011' readStream) =			(Month				month: 2				year: 2011)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testNanoSecond	self assert: aDateAndTime nanoSecond =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21'!testNoon	self assert: aDateAndTime noon =  '2004-02-29T12:00:00+00:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21'!testOffset	self assert: aDateAndTime offset =  '0:02:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '2004-02-29T13:33:00+12:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'nice 2/23/2013 20:32'!testPrintOn	| ref ws |	ref := '2004-02-29T13:33:00+02:00'.	ws := '' writeStream.	aDateAndTime printOn: ws.	self assert: ws contents = ref.	ref  := 'a TimeZone(UTC)'.	ws := '' writeStream.	aTimeZone printOn:  ws.	self assert: ws contents = ref	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testSecond	self assert: aDateAndTime second =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testSeconds	self assert: aDateAndTime seconds =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:12'!testTicks	self assert: aDateAndTime ticks =  ((DateAndTime julianDayNumber: 2453065) + 48780 seconds) ticks.	self assert: aDateAndTime ticks =  #(2453065 48780 0)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:52'!testTicksOffset	self assert: aDateAndTime =  (aDateAndTime ticks:  #(2453065 48780 0) offset: DateAndTime localOffset).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:22'!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:02:00:00') =  '2004-02-29T13:33:00+02:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:17'!testYear	self assert: aDateAndTime year = 2004.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:21'!testYearDayHourMinuteSecond	self assert: aDateAndTime =  ((DateAndTime year: 2004 day: 60 hour: 13 minute: 33 second: 0) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:23'!testYearMonthDayHourMinuteSecond	self assert: aDateAndTime =  ((DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'nk 3/12/2004 11:26'!testtimeZone	self assert: aDateAndTime timeZoneName	= 'Universal Time'.	self assert: aDateAndTime timeZoneAbbreviation	=  'UTC'! !!DateAndTimeLeapTest methodsFor: 'failures' stamp: 'pre 12/13/2018 15:37'!expectedFailures	^ #(testAsSeconds)! !ClassTestCase subclass: #DateAndTimeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!DateAndTimeTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 09:25'!classToBeTested	^ DateAndTime! !!DateAndTimeTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 09:25'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 17:00'!testArithmeticAcrossDateBoundary	| t1 t2 |	t1 := '2004-01-07T11:55:00+00:00' asDateAndTime. 	t2 := t1 - ( (42900+1) seconds).  	self 		assert: t2 = ('2004-01-06T23:59:59+00:00' asDateAndTime)		! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 12/4/2016 11:42'!testAsSecondsMatchesFromSecondsUsingAnyOffset	"Verify that #asSeconds is symmetric with #fromSeconds: for an instance with	offset that does not match the current local time zone offset."	| aDateAndTime seconds newDateAndTime |	aDateAndTime := DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours.	seconds := aDateAndTime asSeconds.	newDateAndTime := DateAndTime fromSeconds: seconds.	self assert: seconds equals: newDateAndTime asSeconds.	"Repeat with another offset to ensure coverage"	aDateAndTime := DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: -11 hours.	seconds := aDateAndTime asSeconds.	newDateAndTime := DateAndTime fromSeconds: seconds.	self assert: seconds equals: newDateAndTime asSeconds.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 12/4/2016 11:39'!testAsSecondsMatchesFromSecondsUsingCurrentLocalOffset	"Verify that #asSeconds is symmetric with #fromSeconds: for an instance with	offset that matches the current local time zone offset."	| seconds newDateAndTime now |	now := DateAndTime now.	seconds := now asSeconds.	newDateAndTime := DateAndTime fromSeconds: seconds.	self assert: seconds equals: newDateAndTime asSeconds.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 12/4/2016 11:39'!testAsSecondsMatchesFromSecondsUsingZeroOffset	"Verify that #asSeconds is symmetric with #fromSeconds: for an instance with	zero offset as in UTC time."	| aDateAndTime seconds newDateAndTime |	aDateAndTime := DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 0 hours.	seconds := aDateAndTime asSeconds.	newDateAndTime := DateAndTime fromSeconds: seconds.	self assert: seconds equals: newDateAndTime asSeconds.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 4/18/2014 21:08'!testAsStringFromString	"Convert to string then back, verify same date and time. Skip years in the	range 0 to 99 because they are interpreted relative to 2000."	| day hour dt min mo nano offset sec dtNew s |	mo := 12.	day := 2.	hour := 2.	min := 3.	sec := 4.	nano := 5.	offset := 6 hours.	(-2000 to: -1) , (100 to: 5000) do: [:yr |		dt := DateAndTime 			year: yr month: mo day: day 			hour: hour minute: min second: sec nanoSecond: nano 			offset: offset.		s := dt asString.		dtNew := DateAndTime fromString: s.		self assert: dt equals: dtNew].! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 11/7/2004 13:00'!testDateTimeDenotation1  "DateAndTimeTest new testDateTimeDenotation1"		 " Detroit is 5 hours behind UTC, this offset to UTC is therefore written with a minus sign. This example tests the correct interpretation of the DateAndTime denotation. "	| twoPmInLondon twoPmUTCInLocalTimeOfDetroit nineAmInDetroit |	twoPmInLondon := DateAndTime				year: 2004				month: 11				day: 2				hour: 14				minute: 0				second: 0				offset: 0 hours.	twoPmUTCInLocalTimeOfDetroit := twoPmInLondon utcOffset: -5 hours.	nineAmInDetroit  := '2004-11-02T09:00:00-05:00' asDateAndTime.	self assert:  twoPmUTCInLocalTimeOfDetroit = nineAmInDetroit.	! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 11/7/2004 13:01'!testDateTimeDenotation2  "DateAndTimeTest new testDateTimeDenotation2"		 " Moscow is 3 hours ahead UTC, this offset to UTC is therefore positive. This example tests the correct interpretation of the DateAndTime denotation. "	| lateEveningInLondon lateEveningInLocalTimeOfMoscow	 localMoscowTimeFromDenotation |	lateEveningInLondon := DateAndTime				year: 2004				month: 11				day: 30				hour: 23				minute: 30				second: 0				offset: 0 hours.	lateEveningInLocalTimeOfMoscow := lateEveningInLondon utcOffset: 3 hours.	localMoscowTimeFromDenotation  := '2004-12-01T02:30:00+03:00' asDateAndTime.	self assert:  lateEveningInLocalTimeOfMoscow = localMoscowTimeFromDenotation.	! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'fbs 11/5/2013 17:37'!testErrorWhenDayIsAfterMonthEnd	self		should:			[DateAndTime				year: 2004				month: 2				day: 30]		raise: Error.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'fbs 11/5/2013 17:37'!testErrorWhenDayIsBeforeMonthStart	self		should:			[DateAndTime				year: 2004				month: 2				day: -1]		raise: Error.	self		should:			[DateAndTime				year: 2004				month: 2				day: 0]		raise: Error.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'jrm 7/5/2012 18:33'!testFromString	| fromString fromStringNoOffset fromStringUTC |	fromString := DateAndTime fromString: '-1199-01-05T20:33:14.321-05:00'.	self assert: (fromString printString = '-1199-01-05T20:33:14.321-05:00').		"if no offset is provided, the local offset should be used"	fromStringNoOffset := DateAndTime fromString: '-1199-01-05T20:33:14.321'.	self assert: (fromStringNoOffset offset = DateAndTime localOffset).		"if a string contains the UTC designator Z, the local offset should not be used"	fromStringUTC := DateAndTime fromString: '2011-08-26T18:00:03Z'.	self assert: (fromStringUTC printString = '2011-08-26T18:00:03+00:00').! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'nice 5/11/2012 22:56'!testHash	| date0 date1 date2 |	date0 := DateAndTime unixEpoch.	date1 := DateAndTime new ticks: (date0 + 1 hours) ticks offset: 0 hours.	date2 := DateAndTime new ticks: (date0 - 2 hours) ticks offset: -3 hours.	self assert: (date1 = date2) ==> [date1 hash = date2 hash]! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 15:37'!testInstanceCreation	| t |	t := DateAndTime 			year: 1 month: 1 day: 2 			hour: 2 minute: 3 second: 4 nanoSecond: 5 			offset: 6 hours.	self 		assert: (t julianDayNumber = 1721427);		assert: (t offset = 6 hours);		assert: (t hour = 2);		assert: (t minute = 3);		assert: (t second = 4);		assert: (t nanoSecond = 5).		! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'nk 3/12/2004 11:06'!testMonotonicity	| t1 t2 t3 t4 |	t1 := DateAndTime now.	t2 := DateAndTime now.	(Delay forMilliseconds: 1000) wait.	t3 := DateAndTime now.	t4 := DateAndTime now.	self		assert: (	t1 <= t2);		assert: (	t2 < t3);		assert: (	t3 <= t4).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'KLC 5/9/2008 20:37'!testPrecision	"Verify that the clock is returning a value with accuracy of better than 1 second.  For now it seems sufficient to get two values and verify they are not the same."	self		assert: (DateAndTime now ~= DateAndTime now)! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'klc 9/9/2010 15:55'!testPrintString	"(self new setTestSelector: #testPrintString) debug"	| dt dtNoOffset |	dt :=DateAndTime		year: 2004		month: 11		day: 2		hour: 14		minute: 3		second: 5		nanoSecond: 12345		offset: (Duration seconds: (5 * 3600)).	self assert: dt printString = '2004-11-02T14:03:05.000012345+05:00'.		self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').	self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  	self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').	self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).	self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').	self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime printString = '2002-05-16T17:20:45-02:34').	self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime printString = '2002-05-16T17:20:45+00:00').	self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime printString = '1997-04-26T01:02:03+01:02:3').	"When no offset is provided, the local one is used"	dtNoOffset := '2002-05-16T17:20' asDateAndTime.	self assert: (('2002-05-16T17:20:00*' match: dtNoOffset printString) and: [dtNoOffset offset = DateAndTime localOffset]).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 7/15/2014 19:49'!testReadFrom	self assert: '-1199-01-05T20:33:14.321-05:00' equals: (DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream) printString.	self assert: '-1199-01-05T20:33:14.321-05:00' equals: '-1199-01-05T20:33:14.321-05:00' asDateAndTime printString.	self assert: '2002-05-16T17:20:45.1+01:01' equals: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString.	self assert: '2002-05-16T17:20:45.02+01:01' equals: ' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString.  	self assert: '2002-05-16T17:20:45.000000009+01:01' equals: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString.	self assert: '2002-05-16T17:20:45+01:57' equals: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString.	self assert: '2002-05-16T17:20:45-02:34' equals: ' 2002-05-16T17:20:45-02:34' asDateAndTime printString.	self assert: '2002-05-16T17:20:45+00:00' equals: '2002-05-16T17:20:45+00:00' asDateAndTime printString.	self assert: '1997-04-26T01:02:03+01:02:3' equals: '1997-04-26T01:02:03+01:02:3' asDateAndTime printString! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 15:43'!testSmalltalk80Accessors	| t |	t := DateAndTime 			year: 1 month: 1 day: 2 			hour: 2 minute: 3 second: 4 nanoSecond: 5 			offset: 6 hours.	self 		assert: (t hours = t hours);		assert: (t minutes = t minute);		assert: (t seconds = t second).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'BG 11/7/2004 12:18'!testTimeZoneEquivalence  "DateAndTimeTest new testTimeZoneEquivalence"	"When the clock on the wall in Detroit says 9:00am, the clock on the wall	in London says 2:00pm. The Duration difference between the corresponding	DateAndTime values should be zero."		 " Detroit is 5 hours behind UTC, this offset to UTC is therefore written with a minus sign. This example tests both the correct interpretation of the DateAndTime denotation and correct DateAndTime arithmetics. "	| twoPmInLondon nineAmInDetroit durationDifference |	twoPmInLondon := '2004-11-02T14:00:00+00:00' asDateAndTime.	nineAmInDetroit  := '2004-11-02T09:00:00-05:00' asDateAndTime.	durationDifference := twoPmInLondon - nineAmInDetroit.	self assert: durationDifference asSeconds = 0.	self assert: twoPmInLondon = nineAmInDetroit! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'BG 11/7/2004 12:17'!testTimeZoneEquivalence2  "DateAndTimeTest new testTimeZoneEquivalence2"	"This example demonstates the fact that        2004-05-24T22:40:00  UTC  is        2004-05-25T01:40:00  in Moscow     (Moscow is 3 hours ahead of UTC)  "	| thisMoment thisMomentInMoscow |    thisMoment := DateAndTime year: 2004 month: 5 day: 24 hour: 22 minute: 40.    thisMomentInMoscow := thisMoment utcOffset: 3 hours.	self assert: (thisMoment - thisMomentInMoscow) asSeconds = 0.	self assert: thisMoment = thisMomentInMoscow! !ClassTestCase subclass: #DateTest	instanceVariableNames: 'date aDate aTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!DateTest commentStamp: 'brp 7/26/2003 16:58' prior: 0!This is the unit test for the class Date. !!DateTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:01'!classToBeTested	^ self dateClass! !!DateTest methodsFor: 'Coverage' stamp: 'brp 1/30/2005 09:03'!selectorsToBeIgnored	 | deprecated private special |	deprecated := #().	private := #().	special := #( #< #= #new #next #previous #printOn: #printOn:format: #storeOn: #fromString: ).	^ super selectorsToBeIgnored, deprecated, private, special! !!DateTest methodsFor: 'Running' stamp: 'brp 1/21/2004 18:46'!setUp	date := self dateClass newDay: 153 year: 1973.	"2 June 1973"	aDate := Date readFrom: '01-23-2004' readStream.	aTime := Time readFrom: '12:34:56 pm' readStream! !!DateTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 16:07'!testAccessing	self			assert: date day = 153;		assert: date julianDayNumber = 2441836;		assert: date leap = 0;		assert: date monthIndex = 6;		assert: date monthName = #June;		assert: date weekday = #Saturday;		assert: date weekdayIndex = 7;		assert: date year = 1973.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:10'!testArithmetic	| d |	d := date addDays: 32.		"4 July 1973"	self 		assert: d year = 1973;		assert: d monthIndex = 7;		assert: d dayOfMonth = 4.	self 		assert: (d subtractDate: date) = 32;		assert: (date subtractDate: d) = -32.	self	 		assert: (d subtractDays: 32) = date.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:54'!testComparing	| d1 d2 d3 |	d1 := self dateClass newDay: 2 month: #June year: 1973.	d2 := self dateClass newDay: 97 year: 2003. 		"7 April 2003"	d3 := self dateClass newDay: 250 year: 1865. 		"7 September 1865"	self		assert: date = d1;		assert: date = date copy;		assert: date hash = d1 hash.	self 		assert: date < d2;		deny: date < d3.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:15'!testConverting	self 		assert: date asDate = date;		assert: '2 June 1973' asDate = date;		assert: date asSeconds = 2285280000.	date dayMonthYearDo: [ :d :m :y | self assert: d = 2; assert: m = 6; assert: y = 1973 ].! !!DateTest methodsFor: 'Tests' stamp: 'tfel 9/1/2009 07:09'!testConvertingFromIso8601	self 		assert: '1973-06-02' asDate = date;		assert: '1973-JUN-02' asDate = date;		assert: '1973-June-02' asDate = date! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:47'!testFromDays	| epoch d0 d1 d2 |	epoch := self dateClass newDay: 1 year: 1901.	d0 := self dateClass fromDays: 0. 			"1 January 1901"	self assert: d0 = epoch.	d1 := self dateClass fromDays:  26450. 	"2 June 1973"	self assert: d1 = date.	d2 := self dateClass fromDays: -100000.	"18 March 1627"	self assert: d2 julianDayNumber = 2315386.	self assert: aDate  =  (Date fromDays:  37642).	self assert: aDate  =  (Date fromDays: 103*365 + 22 + 25 "leap days") .	! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:17'!testFromSeconds	| d |	d := self dateClass fromSeconds: 2285280000. 	self		assert: d = date.! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 16:37'!testGeneralInquiries	| shuffled indices names now | 	shuffled := #(#January #February #March #April #May #June #July 					#August #September #October #November #December) shuffled.	indices := shuffled collect: [ :m | self dateClass indexOfMonth: m ].	names := indices collect: [ :i | self dateClass nameOfMonth: i ].	self assert: names = shuffled.	shuffled := #(#Monday #Tuesday #Wednesday #Thursday #Friday #Saturday #Sunday) shuffled.	indices := shuffled collect: [ :m | self dateClass dayOfWeek: m ].	names := indices collect: [ :i | self dateClass nameOfDay: i ].	self assert: names = shuffled.		now  := self dateClass dateAndTimeNow.	self 		assert: now size = 2;		assert: now first = self dateClass today.	self assert: (self dateClass firstWeekdayOfMonth: #June year: 1973) = 6.	self		assert: (self dateClass leapYear: 1973) = 0;		assert: (self dateClass leapYear: 1972) = 1;		assert: (self dateClass daysInYear: 1973) = 365;		assert: (self dateClass daysInYear: 1972) = 366;		assert: (self dateClass daysInMonth: #February forYear: 1973) = 28;		assert: (self dateClass daysInMonth: #February forYear: 1972) = 29.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:17'!testInitialization	self should: [ self dateClass initialize. true ].! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:18'!testInquiries	self			assert: date dayOfMonth = 2;		assert: date dayOfYear = 153;		assert: date daysInMonth = 30;		assert: date daysInYear = 365;		assert: date daysLeftInYear = (365 - 153);		assert: date firstDayOfMonth = 152.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:05'!testNew	| epoch |	epoch := self dateClass newDay: 1 year: 1901.	self assert: (self dateClass new = epoch).! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 16:33'!testPreviousNext	| n p pt ps |	n := date next.	p := date previous.	self		assert: n year = 1973;		assert: n dayOfYear = 154;		assert: p year = 1973;		assert: p dayOfYear = 152.	pt := date previous: #Thursday.		"31 May 1973"	self			assert: pt year = 1973;		assert: pt dayOfYear = 151.	ps := date previous: #Saturday.		" 26 May 1973"	self			assert: ps year = 1973;		assert: ps dayOfYear = (153-7).! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:21'!testPrinting	self			assert: date mmddyyyy = '6/2/1973';		assert: date yyyymmdd = '1973-06-02';		assert: (date printFormat: #(3 1 2 $!! 2 1 1)) = '1973!!2!!Jun'.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:23'!testReadFrom	| s1 s2 s3 s4 s5 | 	s1 := '2 June 1973'.	s2 := '2-JUN-73'.	s3 := 'June 2, 1973'.	s4 := '6/2/73'.	s5 := '2JUN73'.	self			assert: date = (self dateClass readFrom: s1 readStream);		assert: date = (self dateClass readFrom: s2 readStream);		assert: date = (self dateClass readFrom: s3 readStream);		assert: date = (self dateClass readFrom: s4 readStream);		assert: date = (self dateClass readFrom: s5 readStream).! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:05'!testStoring	self			assert: date storeString = '''2 June 1973'' asDate';		assert: date = ('2 June 1973' asDate).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAddDays	self assert: (aDate addDays: 00) yyyymmdd =  '2004-01-23'.		self assert: (aDate addDays: 30) yyyymmdd =  '2004-02-22'.	self assert: (aDate addDays: 60) yyyymmdd =  '2004-03-23'.	self assert: (aDate addDays: 90) yyyymmdd =  '2004-04-22'.	self assert: (aDate addDays:120) yyyymmdd =  '2004-05-22'! !!DateTest methodsFor: 'testing' stamp: 'tbn 7/11/2006 10:37'!testAddMonths	self assert: (aDate addMonths: 0) yyyymmdd =  '2004-01-23'.		self assert: (aDate addMonths: 1) yyyymmdd =  '2004-02-23'.	self assert: (aDate addMonths: 2) yyyymmdd =  '2004-03-23'.	self assert: (aDate addMonths: 3) yyyymmdd =  '2004-04-23'.	self assert: (aDate addMonths: 12) yyyymmdd =  '2005-01-23'.		self assert: ((Date readFrom: '05-31-2017' readStream) addMonths: 1) yyyymmdd =  '2017-06-30'.	self assert: ((Date readFrom: '02-29-2000' readStream) addMonths: 12) yyyymmdd =  '2001-02-28'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAsDate	self assert: (aDate asDate) = aDate! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAsSeconds	self assert: (aDate asSeconds) =   3252268800.	self assert: (aDate asSeconds) =  ((103*365*24*60*60) + (22+25"leap days"*24*60*60)) .	self assert: aDate  =  (Date fromSeconds: 3252268800).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDateAndTimeNow	"Not a great test: could falsely fail if midnight come in between the two executions and doesnt catch time errors"	self assert: Date dateAndTimeNow first  = Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDayMonthYearDo	self assert: (aDate dayMonthYearDo: [:day :month :year | day asString , month asString, year asString]) = '2312004'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDaysInMonthForYear	self assert: (Date daysInMonth: 'February' forYear: 2008)  = 29.		self assert: (Date daysInMonth: 'February' forYear: 2000)  = 29.		self assert: (Date daysInMonth: 'February' forYear: 2100)  = 28.		self assert: (Date daysInMonth: 'July' forYear: 2100)  = 31.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDaysInYear	self assert: (Date daysInYear: 2008)  = 366.		self assert: (Date daysInYear: 2000)  = 366.		self assert: (Date daysInYear: 2100)  = 365	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDuration	self assert: aDate duration = 24 hours! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testEqual	self assert: aDate = (Date readFrom: (ReadStream on: 'January 23, 2004')).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testFirstWeekdayOfMonthYear	self assert: (Date firstWeekdayOfMonth: 'January' year: 2004)  = 5.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testIndexOfMonth	self assert: (Date indexOfMonth: 'January')  = 1.		self assert: (Date indexOfMonth: 'December')  = 12.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testJulianDayNumber	self assert: aDate = (Date julianDayNumber: ((4713+2004)*365 +1323) ).  ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLeap	self assert: aDate leap = 1.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLeapNot	self assert: (aDate addDays: 365) leap = 0! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLessThan	self assert: aDate < (Date readFrom: (ReadStream on: '01-24-2004')).! !!DateTest methodsFor: 'testing' stamp: 'dtl 12/4/2016 12:15'!testMakeUTC	"Equal dates should compare equal regardless of which TimeZone they are created in."	| priorTz priorPreference march31stLocal march31stOcean | 	priorTz := DateAndTime localTimeZone.	priorPreference := DateAndTime automaticTimezone.	[DateAndTime 		localTimeZone: (TimeZone		offset: 9 hours		name: 'Early Test Countries'		abbreviation: 'Test Ocean Early').  	march31stLocal := Date year: 2016 month: 3 day: 31.	march31stLocal start: (march31stLocal start offset: DateAndTime localTimeZone offset). 	DateAndTime		localTimeZone: (TimeZone		offset: -9 hours		name: 'Late Test Countries'		abbreviation: 'Test Ocean Late'). 	march31stOcean := Date year: 2016 month: 3 day: 31.	march31stOcean start: (march31stOcean start offset: DateAndTime localTimeZone offset).] 		ensure: [DateAndTime localTimeZone: priorTz.				DateAndTime automaticTimezone: priorPreference]. 	self 		deny: march31stLocal = march31stOcean;		assert: march31stOcean > march31stLocal. 	self 		assert: march31stLocal makeUTC = march31stOcean makeUTC;		deny: march31stOcean makeUTC > march31stLocal makeUTC;		deny: march31stOcean makeUTC < march31stLocal makeUTC.! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testMmddyyyy	self assert: aDate mmddyyyy =  '1/23/2004'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNameOfMonth	self assert: (Date nameOfMonth: 5) = 'May'.		self assert: (Date nameOfMonth: 8) = 'August' ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNewDayMonthYear	self assert: aDate = (Date newDay: 23 month: 1 year: 2004)	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNewDayYear	self assert: aDate = (Date newDay: 23 year: 2004)	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPreviousFriday	self assert: (aDate previous: 'Friday') yyyymmdd = '2004-01-16'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPreviousThursday	self assert: (aDate previous: 'Thursday') yyyymmdd = '2004-01-22'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPrintFormat	self assert: (aDate printFormat: #(1 2 3 $? 2 2)) =  '23?Jan?04'! !!DateTest methodsFor: 'testing' stamp: 'nice 2/23/2013 20:15'!testPrintOn	| ref ws |	ref := '23 January 2004'.	ws := '' writeStream.	aDate printOn: ws.	self assert: ws contents = ref! !!DateTest methodsFor: 'testing' stamp: 'nice 2/23/2013 20:16'!testPrintOnFormat	| ref ws |	ref :='04*Jan*23'.	ws := '' writeStream.	aDate printOn: ws format: #(3 2 1 $* 2 2).	self assert: ws contents = ref! !!DateTest methodsFor: 'testing' stamp: 'cmm 2/2/2012 22:09'!testStarting	self assert: aDate = (Date starting: ((DateAndTime fromString: '2004-01-23T12:12') offset: Date defaultOffset))! !!DateTest methodsFor: 'testing' stamp: 'nice 2/23/2013 20:17'!testStoreOn	| ref ws |	ref := '''23 January 2004'' asDate'.	ws := '' writeStream.	aDate storeOn: ws.	self assert: ws contents = ref! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testSubtractDate	self assert: (aDate subtractDate:(aDate addDays: 30)) = -30.		self assert: (aDate subtractDate:(aDate subtractDays: 00)) = 0.		self assert: (aDate subtractDate:(aDate subtractDays: 30)) = 30.! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testSubtractDays	self assert: (aDate subtractDays: 00) yyyymmdd =  '2004-01-23'.		self assert: (aDate subtractDays: 30) yyyymmdd =  '2003-12-24'.	self assert: (aDate subtractDays: 60) yyyymmdd =  '2003-11-24'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testTomorrow	"Not a great test: could falsely fail if midnight come in between the two executions and doesnt catch many errors"	self assert: Date tomorrow  > Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testWeekday	self assert: aDate weekday = 'Friday'.		self assert: aDate weekdayIndex = 6. 	self assert: (Date dayOfWeek: aDate weekday ) =6.	self assert: (Date nameOfDay: 6 ) = 'Friday'	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testYesterday	"Not a great test:  doesnt catch many errors"	self assert: Date yesterday  < Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testYyyymmdd	self assert: aDate yyyymmdd =  '2004-01-23'! !!DateTest methodsFor: 'Private' stamp: 'brp 8/24/2003 00:10'!dateClass	^ Date! !ClassTestCase subclass: #DurationTest	instanceVariableNames: 'aDuration'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!DurationTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 14:30'!classToBeTested	^ Duration! !!DurationTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 14:30'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!DurationTest methodsFor: 'running' stamp: 'brp 1/21/2004 18:36'!setUp	aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5 ! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:32'!testComparing	| d1 d2 d3 |	d1 := Duration seconds: 10 nanoSeconds: 1.	d2 := Duration seconds: 10 nanoSeconds: 1.	d3 := Duration seconds: 10 nanoSeconds: 2.		self		assert: (d1 = d1);		assert: (d1 = d2);		deny: (d1 = d3);		assert: (d1 < d3)! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:36'!testModulo	| d1 d2 d3 |	d1 := 11.5 seconds.	d2 := d1 \\ 3.	self assert: d2 = (Duration nanoSeconds: 1).	d3 := d1 \\ (3 seconds).	self assert: d3 =  (Duration seconds: 2 nanoSeconds: 500000000).	self assert: aDuration \\ aDuration = 		(Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0). 	self assert: aDuration \\ 2 = 		(Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 1).	! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/16/2004 14:17'!testMonthDurations	| jan feb dec |	jan := Duration month: #January.	feb := Duration month: #February.	dec := Duration month: #December.		self 		assert: jan = (Year current months first duration);		assert: feb = (Year current months second duration);		assert: dec = (Year current months last duration)		! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:28'!testNumberConvenienceMethods	self		assert: 1 week = (Duration days: 7);		assert: -1 week = (Duration days: -7);		assert: 1 day = (Duration days: 1);		assert: -1 day = (Duration days: -1);		assert: 1 hours = (Duration hours: 1);		assert: -1 hour = (Duration hours: -1);		assert: 1 minute = (Duration seconds: 60);		assert: -1 minute = (Duration seconds: -60);		assert: 1 second = (Duration seconds: 1);		assert: -1 second = (Duration seconds: -1);		assert: 1 milliSecond = (Duration milliSeconds: 1);		assert: -1 milliSecond = (Duration milliSeconds: -1);		assert: 1 nanoSecond = (Duration nanoSeconds: 1);		assert: -1 nanoSecond = (Duration nanoSeconds: -1)		! !!DurationTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 14:57'!testQuotient	| d1 d2 q |	d1 := 11.5 seconds.	d2 := d1 // 3.	self assert: d2 = (Duration seconds: 3 nanoSeconds: 833333333).	q := d1 // (3 seconds).	self assert: q = 3.! !!DurationTest methodsFor: 'Tests' stamp: 'ar 9/2/2009 19:57'!testReadFromTrailingDigits	"http://bugs.squeak.org/view.php?id=6764"	self should:  (Duration readFrom: '0:00:00:00.001 ' readStream) nanoSeconds = 1000000.! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:38'!testRoundTo	self assert: ((5 minutes + 37 seconds) roundTo: (2 minutes)) = (6 minutes).		self assert:  (aDuration roundTo: (Duration days: 1)) =	               (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).	self assert:  (aDuration roundTo: (Duration hours: 1)) =	               (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).		self assert:  (aDuration roundTo: (Duration minutes: 1)) =	               (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0).! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:37'!testTruncateTo	self assert: ((5 minutes + 37 seconds) truncateTo: (2 minutes)) = (4 minutes).	self assert:  (aDuration truncateTo: (Duration days: 1)) =	               (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).	self assert:  (aDuration truncateTo: (Duration hours: 1)) =	               (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).		self assert:  (aDuration truncateTo: (Duration minutes: 1)) =	               (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0).! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAbs	self assert: aDuration abs = aDuration. 	self assert: (Duration nanoSeconds: -5)  abs =  (Duration nanoSeconds: 5). ! !!DurationTest methodsFor: 'testing' stamp: 'fbs 11/5/2013 08:33'!testAgo	self assert: ((10 minutes ago) isMemberOf: DateAndTime).	self assert: ((10 weeks ago) < DateAndTime now).	self assert: ((-50 seconds ago) > DateAndTime now).	self assert: ((10 hours ago) < DateAndTime now).	self assert: (0 seconds ago - DateAndTime now < 1 second).! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsDelay	self deny: aDuration asDelay =   aDuration.	"want to come up with a more meaningful test"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsDuration	self assert: aDuration asDuration =  aDuration	! !!DurationTest methodsFor: 'testing' stamp: 'cmm 4/8/2010 12:19'!testAsMilliSeconds	self assert: (Duration nanoSeconds: 1000000) asMilliSeconds = 1.	self assert: (Duration seconds: 1) asMilliSeconds = 1000.	self assert: (Duration nanoSeconds: 1000000) asMilliSeconds = 1.	self assert: (Duration nanoSeconds: 1000000) asMilliSeconds = 1.	self assert: aDuration asMilliSeconds = 93784000.	self assert: (Duration milliSeconds: 3775) asSeconds = 3.	self assert: (Duration milliSeconds: 3775) nanoSeconds = 775000000! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsNanoSeconds	self assert: (Duration nanoSeconds: 1)  asNanoSeconds = 1.	self assert: (Duration seconds: 1)  asNanoSeconds = 1000000000.		self assert: aDuration   asNanoSeconds = 93784000000005.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsSeconds	self assert: (Duration nanoSeconds: 1000000000)  asSeconds = 1.	self assert: (Duration seconds: 1)  asSeconds = 1.		self assert: aDuration   asSeconds = 93784.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testDays	self assert: aDuration   days = 1.	self assert: (Duration   days: 1) days= 1.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testDivide	self assert: aDuration / aDuration = 1. 	self assert: aDuration / 2 = (Duration days: 0 hours: 13 minutes: 1 seconds: 32 nanoSeconds: 2). 	self assert: aDuration / (1/2) = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10).! !!DurationTest methodsFor: 'testing' stamp: 'fbs 11/5/2013 08:35'!testFromNow	self assert: ((10 seconds fromNow) > DateAndTime now).	self assert: ((0 days fromNow - DateAndTime now) < 1 second).	self assert: ((-1 weeks fromNow) < DateAndTime now).	self assert: ((1000 milliSeconds fromNow) isMemberOf: DateAndTime).	self assert: ((250 hours fromNow) > DateAndTime now).	self assert: ((-50 minutes fromNow) < DateAndTime now).! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testFromString	self assert: aDuration = (Duration fromString: '1:02:03:04.000000005').! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testHash	self assert: aDuration hash =    	(Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) hash.	self assert: aDuration hash =     93789	"must be a more meaningful test?"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testHours	self assert: aDuration   hours = 2.	self assert: (Duration   hours: 2) hours = 2.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testIntegerDivision	self assert: aDuration // aDuration = 1. 	self assert: aDuration // 2 =  (aDuration / 2). 	"is there ever a case where this is not true, since precision is always to the nano second?"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testLessThan	self assert: aDuration  < (aDuration + 1 day ).	self deny: aDuration < aDuration.	! !!DurationTest methodsFor: 'testing' stamp: 'ul 4/28/2010 09:57'!testMilliSeconds	#(		"argument (milliseconds)	seconds	nanoseconds"		(5							0			5000000)		(1005						1			5000000)		(-5							0			-5000000)		(-1005						-1			-5000000)		(1234567					1234		567000000)		(-1234567					-1234		-567000000)			) do: [ :each |		| duration |		duration := Duration milliSeconds: each first.		self assert: duration asSeconds = each second.		self assert: duration nanoSeconds = each third ]! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMinus	self assert: aDuration - aDuration = (Duration seconds: 0).	self assert: aDuration - (Duration days: -1 hours: -2 minutes: -3 seconds: -4 nanoSeconds: -5) = 						    (Duration days: 2  hours: 4  minutes: 6  seconds: 8  nanoSeconds: 10). 	self assert: aDuration - (Duration days: 0  hours: 1  minutes: 2  seconds: 3  nanoSeconds: 4) = 						    (Duration days: 1  hours: 1  minutes: 1  seconds: 1  nanoSeconds: 1). 	self assert: aDuration - (Duration days: 0  hours: 3   minutes: 0  seconds: 5  nanoSeconds: 0) = 						    (Duration days: 0  hours: 23  minutes: 2  seconds: 59  nanoSeconds: 5). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMinutes	self assert: aDuration   minutes = 3.	self assert: (Duration minutes: 3) minutes = 3.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMultiply	self assert: aDuration * 2 = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNanoSeconds	self assert: aDuration nanoSeconds = 5.	self assert: (Duration nanoSeconds: 5) nanoSeconds = 5.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNegated	self assert: aDuration + aDuration negated = (Duration seconds: 0). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNegative	self deny: aDuration negative.	self assert: aDuration negated negative! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNew	"self assert: Duration new =  (Duration seconds: 0)."    "new is not valid as a creation method: MessageNotUnderstood: UndefinedObject>>quo:, where Duration seconds is nil"! !!DurationTest methodsFor: 'testing' stamp: 'dtl 8/29/2010 11:25'!testNormalizeNanoSeconds	"Subtraction of two DateAndTime values may result in a request to	create a Duration with negative nanoseconds and positive seconds.	The resulting Duration should be normalized, otherwise its printString	will be invalid."	| d t1 t2 |	t1 := '2004-01-07T11:55:01+00:00' asDateAndTime. 	t2 := '2004-01-07T11:55:00.9+00:00' asDateAndTime.	d := t1 - t2. "100 millisecond difference"	self assert: d nanoSeconds > 0.	self assert: d seconds = 0.	self assert: d nanoSeconds = 100000000.	self assert: d asString = '0:00:00:00.1'.	"Verify that other combinations produces reasonable printString values"	self assert: (Duration seconds: 1 nanoSeconds: 100000000) printString = '0:00:00:01.1'.	self assert: (Duration seconds: -1 nanoSeconds: -100000000) printString = '-0:00:00:01.1'.	self assert: (Duration seconds: 1 nanoSeconds: -100000000) printString = '0:00:00:00.9'.	self assert: (Duration seconds: -1 nanoSeconds: 100000000) printString = '-0:00:00:00.9'! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPlus	self assert: (aDuration + 0 hours) = aDuration.	self assert: (aDuration + aDuration) = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPositive	self assert: (Duration nanoSeconds: 0) positive.	self assert: aDuration positive.	self deny: aDuration negated positive! !!DurationTest methodsFor: 'testing' stamp: 'nice 2/23/2013 20:18'!testPrintOn	| ref ws |	ref := '1:02:03:04.000000005'.	ws := '' writeStream.	aDuration printOn: ws.	self assert: ws contents = ref! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testReadFrom	self assert: aDuration =  (Duration readFrom: (ReadStream on: '1:02:03:04.000000005'))! !!DurationTest methodsFor: 'testing' stamp: 'KLC 5/12/2008 13:41'!testSeconds	self assert: aDuration seconds =   4.	self assert: (Duration  nanoSeconds: 2) seconds = 0.	self assert: (Duration nanoSeconds: 999999999) seconds = 0.	self assert: (Duration nanoSeconds: 1000000001) seconds = 1.	self assert: (Duration  seconds: 2) seconds = 2.		self assert: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = 4.	self deny: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = (1*24*60*60+(2*60*60)+(3*60)+4).	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testSecondsNanoSeconds 	self assert: (Duration   seconds: 0 nanoSeconds: 5)  = (Duration  nanoSeconds: 5).		"not sure I should include in sunit since its Private "	self assert: (aDuration seconds: 0 nanoSeconds: 1) = (Duration nanoSeconds: 1). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testStoreOn     self assert: (aDuration storeOn: (WriteStream on:'')) asString ='1:02:03:04.000000005'.      "storeOn: returns a duration (self) not a stream"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testTicks	self assert: aDuration ticks =  #(1 7384 5)! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testWeeks	self assert: (Duration  weeks: 1) days= 7.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testZero	self assert: (Duration zero) = (Duration seconds: 0).	! !ClassTestCase subclass: #MonthTest	instanceVariableNames: 'month'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!MonthTest commentStamp: 'brp 7/26/2003 22:44' prior: 0!This is the unit test for the class Month.!!MonthTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 12:42'!classToBeTested	^ Month! !!MonthTest methodsFor: 'Coverage' stamp: 'brp 7/26/2003 23:29'!selectorsToBeIgnored	| deprecated private special |	deprecated := #().	private := #( #printOn: ).	special := #( #next ).	^ super selectorsToBeIgnored, deprecated, private, special.! !!MonthTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:37'!setUp	super setUp.	month := Month month: 7 year: 1998.! !!MonthTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:37'!tearDown	super tearDown.	month := nil.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:52'!testConverting	self assert: month asDate = '1 July 1998' asDate! !!MonthTest methodsFor: 'Tests' stamp: 'brp 1/30/2005 09:35'!testEnumerating	| weeks |	weeks := OrderedCollection new.	month weeksDo: [ :w | weeks add: w start ].	0 to: 4 do: [ :i | weeks remove: (Week starting:  ('29 June 1998' asDate addDays: i * 7)) start ].	self assert: weeks isEmpty! !!MonthTest methodsFor: 'Tests' stamp: 'ul 3/27/2011 17:27'!testIndexOfMonth	| m |	m := #(#January #February #March #April #May #June #July #August #September #October #November #December).		m withIndexDo: [:item :index | self assert: (Month indexOfMonth: item) = index].		self should: [Month indexOfMonth: 1] raise: TestResult error.	self should: [Month indexOfMonth: #'1'] raise: TestResult error.	self should: [Month indexOfMonth: #Marsh] raise: TestResult error. "notice the misspell!!"	self should: [Month indexOfMonth: #UnexistingMonth] raise: TestResult error.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 16:08'!testInquiries	self 		assert: month index = 7;		assert: month name = #July;		assert: month duration = (31 days).! !!MonthTest methodsFor: 'Tests' stamp: 'nk 7/30/2004 17:52'!testInstanceCreation	| m1 m2 |	m1 := Month starting:  '4 July 1998' asDate.	m2 := Month month: #July year: 1998.	self		assert: month = m1;		assert: month = m2! !!MonthTest methodsFor: 'Tests' stamp: 'it 7/14/2009 01:17'!testNameOfMonth	| m |	m := #(#January #February #March #April #May #June #July #August #September #October #November #December).		m withIndexDo: [:item :index | self assert: (Month nameOfMonth: index) = item].		self should: [Month nameOfMonth: 0] raise: TestResult error.	self should: [Month nameOfMonth: 13] raise: TestResult error.	self should: [Month nameOfMonth: #January] raise: TestResult error.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 23:02'!testPreviousNext	| n p |	n := month next.	p := month previous.	self		assert: n year = 1998;		assert: n index = 8;		assert: p year = 1998;		assert: p index = 6.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:50'!testPrinting	self 		assert: month printString = 'July 1998'.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:46'!testReadFrom	| m |	m := Month readFrom: 'July 1998' readStream.	self 		assert: m = month! !ClassTestCase subclass: #ScheduleTest	instanceVariableNames: 'firstEvent aSchedule restoredTimeZone localTimeZonePreferenceToRestore'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!ScheduleTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 16:03'!classToBeTested	^ Schedule! !!ScheduleTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 16:03'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!ScheduleTest methodsFor: 'running' stamp: 'dtl 12/4/2016 12:16'!setUp 	 "Schedule is a type of Timespan representing repeated occurences of the same event. 	The beginning of the schedule is the first occurrence of the event.	A schedule maintains an array of Durations. 	Each durations specify the offset to the next scheduled each. 	The duration of each occurence of the event is not specified. 	Nor are any other attributes such as name"	restoredTimeZone := DateAndTime localTimeZone.	localTimeZonePreferenceToRestore := DateAndTime automaticTimezone.	DateAndTime localTimeZone: (TimeZone timeZones detect: [:tz | tz abbreviation = 'GMT']).	"Create aSchedule with an event scheduled for 8:30pm every Saturday 	and Sunday for the year 2003. "	"Create the first event occurring on the first Saturday at 8:30 pm: 1/4/03"	firstEvent :=  DateAndTime year: 2003 month: 1 day: 4 hour: 20 minute: 30. 		"Create a schedule for one year starting with the first event" 	aSchedule := Schedule starting: firstEvent duration: 52 weeks.	"Schedule the recurring events by scheduling the time in between each one.  	One day for Sat-Sun. 6 days for Sun-Sat" 	aSchedule schedule: { Duration days: 1. Duration days: 6 }.! !!ScheduleTest methodsFor: 'running' stamp: 'dtl 12/4/2016 12:16'!tearDown	DateAndTime localTimeZone: restoredTimeZone.	DateAndTime automaticTimezone: localTimeZonePreferenceToRestore. ! !!ScheduleTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 16:08'!testFromDateAndTime	| oc1 oc2 |	oc1 := OrderedCollection new.	DateAndTime today to: DateAndTime tomorrow by: 10 hours do: [ :dt | oc1 add: dt ].	oc2 := { DateAndTime today. 			(DateAndTime today + 10 hours). 				(DateAndTime today + 20 hours) }.	self assert: (oc1 asArray = oc2)! !!ScheduleTest methodsFor: 'Tests' stamp: 'nk 3/30/2004 10:34'!testMonotonicity	| t1 t2 t3 t4 |	t1 := DateAndTime now.	t2 := DateAndTime now.	t3 := DateAndTime now.	t4 := DateAndTime now.	self 		assert: (	t1 <= t2);		assert: (	t2 <= t3);		assert: (	t3 <= t4).! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoDisjointWithSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2004				month: 4				day: 1)		and: (DateAndTime				year: 2004				month: 4				day: 30)		do: [:each | count := count + 1].	self assert: count = 0! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoIncludedInSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2003				month: 4				day: 1)		and: (DateAndTime				year: 2003				month: 4				day: 30)		do: [:each | count := count + 1].	self assert: count = 8! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoOverlappingSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2002				month: 12				day: 1)		and: (DateAndTime				year: 2003				month: 1				day: 31)		do: [:each | count := count + 1].	self assert: count = 8! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testDateAndTimes	| answer |	self assert: aSchedule dateAndTimes size  = 104.	self assert: aSchedule dateAndTimes first = firstEvent.	answer := true.	aSchedule dateAndTimes do: [:each | (each dayOfWeekName = 'Saturday'		or: [each dayOfWeekName = 'Sunday']) ifFalse: [^false]].	self assert: answer! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testExampleFromSwikiPage	"It is often neccessary to schedule repeated events, like airline flight schedules, TV programmes, and file backups.	 Schedule is a Timespan which maintains an array of Durations.	 The durations specify the offset to the next scheduled DateAndTime. "	"Consider a TV programme scheduled for 8:30pm every Saturday and Sunday for the current year. "	"Find the first Saturday and set its time to 20h30"	| sat shows |	sat := Year current asMonth dates detect: [ :d | d dayOfWeekName = #Saturday ].	sat := sat start + (Duration hours: 20.5).	"Create a schedule" 	shows := Schedule starting: sat ending: Year current end.	shows schedule: { Duration days: 1. Duration days: 6 }.	"To inspect:"	shows dateAndTimes.	shows dateAndTimes collect: [ :dt | dt dayOfWeekName ].! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testIncludes	self assert: (aSchedule includes: (DateAndTime year: 2003 month: 6 day: 15 hour: 20 minute: 30 second: 0 offset: 0 hours))	! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testSchedule	self assert: aSchedule schedule size = 2.	self assert: aSchedule schedule first = 1 days.		self assert: aSchedule schedule second = 6 days.! !ClassTestCase subclass: #StopwatchTest	instanceVariableNames: 'aStopwatch aDelay'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!StopwatchTest methodsFor: 'Coverage' stamp: 'brp 9/24/2003 22:49'!classToBeTested	^ Stopwatch! !!StopwatchTest methodsFor: 'Coverage' stamp: 'brp 9/24/2003 23:01'!selectorsToBeIgnored	| private | 	private := #( #printOn: #state: ).	^ super selectorsToBeIgnored, private! !!StopwatchTest methodsFor: 'running' stamp: 'brp 1/21/2004 18:49'!setUp	aStopwatch := Stopwatch new.	aDelay := Delay forMilliseconds: 1.! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:45'!testActive	| sw |	sw := Stopwatch new.	sw activate.		1 seconds asDelay wait.	self 		assert: (sw duration >= 1 seconds).	2 seconds asDelay wait.	self 		assert: (sw duration >= 3 seconds).	sw suspend.! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/24/2003 22:56'!testNew	| sw |	sw := Stopwatch new.		self 		assert: (sw isSuspended);		assert: (sw state = #suspended);		deny: (sw isActive);		assert: (sw timespans isEmpty)! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 12:02'!testReActivate	| sw |	sw := Stopwatch new.	sw 		activate;		suspend;		reActivate.		self 		assert: (sw isActive).! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:56'!testReset	| sw |	sw := Stopwatch new.	sw activate.		sw reset.	self 		assert: (sw isSuspended);		assert: (sw timespans isEmpty)! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/26/2004 19:36'!testStartStop	| sw t1 t2 t3 t4 |	sw := Stopwatch new.	t1 := DateAndTime now.	(Delay forMilliseconds: 10) wait.	sw activate; activate.	(Delay forMilliseconds: 10) wait.	t2 := DateAndTime now.		self 		deny: (sw isSuspended);		assert: (sw isActive);		assert: (sw timespans size = 1);		assert: (t1 <= sw start);		assert: (sw start <= t2).	(Delay forMilliseconds: 10) wait.	t3 := DateAndTime now.	(Delay forMilliseconds: 10) wait.	sw suspend; suspend.	(Delay forMilliseconds: 10) wait.	t4 := DateAndTime now.	self 		assert: (sw isSuspended);		deny: (sw isActive);		assert: (sw timespans size = 1);		assert: (sw end between: t3 and: t4);		assert: (t3 <= sw end);		assert: (sw end <= t4).! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testChangingStatus	aStopwatch activate.	self assert: aStopwatch isActive.	self assert: aStopwatch timespans size = 1.	aStopwatch suspend.	self assert: aStopwatch isSuspended.	self assert: aStopwatch timespans size = 1.	aStopwatch activate.	aStopwatch reActivate.	self assert: aStopwatch isActive.	self assert: aStopwatch timespans size = 3.	aStopwatch reset.	self assert: aStopwatch isSuspended.	self assert: aStopwatch timespans size = 0.! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testInitialStatus	self assert: aStopwatch isSuspended.	self deny: aStopwatch isActive.	self assert: aStopwatch duration = 0 seconds! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 9/26/2004 19:32'!testMultipleTimings	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	self assert: aStopwatch timespans size = 2. 	self assert: aStopwatch timespans first asDateAndTime <= 					aStopwatch timespans last asDateAndTime.! !!StopwatchTest methodsFor: 'testing' stamp: 'nice 2/23/2013 20:26'!testPrintOn	| ref ws |	ref := 'a Stopwatch(suspended:0:00:00:00)'.	ws := '' writeStream.	aStopwatch printOn: ws.	self assert: ws contents = ref! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 9/26/2004 19:32'!testSingleTiming	| timeBefore |	timeBefore := DateAndTime now.	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	self assert: aStopwatch timespans size = 1. 	self assert: aStopwatch timespans first asDateAndTime >= timeBefore. 	self assert: aStopwatch timespans first asDateAndTime <= aStopwatch end.! !ClassTestCase subclass: #TimeStampTest	instanceVariableNames: 'timestamp aTimeStamp'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!TimeStampTest commentStamp: 'brp 7/26/2003 22:44' prior: 0!This is the unit test for the class TimeStamp.!!TimeStampTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:50'!classToBeTested	^ self timestampClass! !!TimeStampTest methodsFor: 'Coverage' stamp: 'brp 1/30/2005 09:13'!selectorsToBeIgnored	| deprecated private special |	deprecated := #().	private := #( #printOn: ).	special := #().	^ super selectorsToBeIgnored, deprecated, private, special.! !!TimeStampTest methodsFor: 'Running' stamp: 'brp 1/21/2004 18:41'!setUp	timestamp := self timestampClass date: ('1-10-2000' asDate) time: ('11:55:00 am' asTime).	aTimeStamp := TimeStamp readFrom: '1-02-2004 12:34:56 am' readStream! !!TimeStampTest methodsFor: 'Running' stamp: 'brp 7/26/2003 21:53'!tearDown	timestamp := nil.! !!TimeStampTest methodsFor: 'Tests' stamp: 'cmm 2/2/2012 22:11'!testAccessing	| d t |	d := '1-10-2000' asDate.	t := '11:55:00 am' asTime.	self		assert: (timestamp offset: Date defaultOffset) date = d;		assert: (timestamp offset: Date defaultOffset) time = t.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:05'!testArithmetic	| ts |	ts := timestamp minusDays: 123.  	"9 September 1999, 11:55 am"	ts := ts minusSeconds: 1056.			"9 September 1999, 11:37:24 am"	ts := ts plusDays: 123.				"10 January 2000, 11:37:24 am"	ts := ts plusSeconds: 1056.			"10 January 2000, 11:55 am"	self		assert: ts  = timestamp.	! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:34'!testArithmeticAcrossDateBoundary	| ts |	ts := timestamp minusSeconds: ((11*3600) + (55*60) + 1).	self		assert: ts = ('1-9-2000 11:59:59 pm' asTimeStamp).	! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 3/12/2004 15:54'!testComparing	| ts1 ts2 ts3 c1 c2 le |	ts1 := self timestampClass date: ('01-10-2000' asDate) time: ('11:55:00 am' asTime).	ts2 := self timestampClass date: ('07-26-2003' asDate) time: ('22:09:45 am' asTime).	ts3 := self timestampClass date: ('05-28-1972' asDate) time: ('04:31:14 pm' asTime).	self		assert: ts1 = timestamp;		assert: ts1 hash = timestamp hash;		assert: timestamp = timestamp copy;		assert: ts1 < ts2;		deny: ts1 < ts3.	c1 := self timestampClass current.	c2 := self timestampClass current.	le := (c1 <= c2).	self assert: le.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:19'!testConverting	| d t |	d := '1-10-2000' asDate.	t := '11:55:00 am' asTime.	self		assert: timestamp asSeconds = (d asSeconds + t asSeconds);		assert: timestamp asDate = d;		assert: timestamp asTime = t;		assert: timestamp asTimeStamp == timestamp;		assert: timestamp dateAndTime = {d. t}.! !!TimeStampTest methodsFor: 'Tests' stamp: 'dtl 11/4/2012 12:51'!testFromSeconds	"A time stamp from seconds is created in the local time zone, so offset may	be non-zero. The test timestamp has offset zero (implying UTC). Comparison	to the test timestamp should succeed if and only if both time stamps are	created relative to the same time zone (UTC)."	| local utc |	local := self timestampClass fromSeconds: 3124958100.	local offset = Duration zero		ifTrue: [self assert: local = timestamp.]		ifFalse: [self deny: local = timestamp.].	utc := local offset: Duration zero.	self assert: utc = timestamp.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 15:02'!testFromString	"This should signal an exception in 3.6beta as Time>>fromString: does not exist."	self should: [ timestamp = (self timestampClass fromString: '1-10-2000 11:55:00 am') ] ! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 1/30/2005 09:12'!testInstanceCreation	self 		should: [ self timestampClass midnight asDuration = (0 hours) ];		should: [ self timestampClass noon asDuration = (12 hours) ].! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 15:02'!testPrinting	self			assert: timestamp printString = '10 January 2000 11:55 am'.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 17:47'!testSorting	| c1 c2 |	c1 := self timestampClass current.	c2 := self timestampClass current.	self		assert: (self timestampClass current) <= (self timestampClass current);		assert: (c1 <= c2).! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testDate	self assert: aTimeStamp date = '01-02-2004' asDate! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testDateAndTime	self assert: aTimeStamp dateAndTime			= (Array with: '01-02-2004' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusDays	self assert: (aTimeStamp minusDays: 5) dateAndTime			= (Array with: '12-28-2003' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusSeconds	self assert: (aTimeStamp minusSeconds: 34 * 60 + 56) dateAndTime			= (Array with: '01-02-2004' asDate with: '00:00:00' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusSecondsOverMidnight	self assert: (aTimeStamp minusSeconds: 34 * 60 + 57) dateAndTime			= (Array with: '01-01-2004' asDate with: '23:59:59' asTime)	"Bug The results are actual results are: #(1 January 2005 11:25:03 pm)"! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusDays	self assert: (aTimeStamp plusDays: 366) dateAndTime			= (Array with: '01-02-2005' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusSeconds	self assert: (aTimeStamp plusSeconds: 60 * 60 ) dateAndTime			= (Array with: '01-02-2004' asDate with: '01:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusSecondsOverMidnight	self assert: (aTimeStamp plusSeconds: 24 * 60 * 60 + 1) dateAndTime			= (Array with: '01-03-2004' asDate with: '00:34:57' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'nice 2/23/2013 19:40'!testPrintOn	| ref ws |	ref := '2 January 2004 12:34:56 am'.	ws := '' writeStream.	aTimeStamp printOn: ws.	self assert: ws contents = ref! !!TimeStampTest methodsFor: 'testing' stamp: 'dtl 11/4/2012 12:43'!testReadFromA1	"Conversion to and from a string (with implied UTC offset) is equal if	and only if the time stamp has zero offset."	|ts|	ts := TimeStamp current offset: Duration zero. "current as UTC"	self assert: (ts = (TimeStamp fromString: ts asString)).	ts := TimeStamp current offset: (Duration hours: 1).	self deny: (ts = (TimeStamp fromString: ts asString)).! !!TimeStampTest methodsFor: 'testing' stamp: 'nice 2/23/2013 19:38'!testStoreOn	| ref ws |	ref := '''2 January 2004 12:34:56 am'' asTimeStamp'.	ws := '' writeStream.	aTimeStamp storeOn: ws.	self assert: ws contents = ref! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testTime	self assert: aTimeStamp time =  '00:34:56' asTime! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testTimeStamp	self assert: aTimeStamp = aTimeStamp asTimeStamp! !!TimeStampTest methodsFor: 'Private' stamp: 'brp 7/27/2003 13:50'!timestampClass	^ TimeStamp! !ClassTestCase subclass: #TimeTest	instanceVariableNames: 'time aTime localTimeZoneToRestore timeWithNanos localTimeZonePreferenceToRestore'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!TimeTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Time.!!TimeTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:31'!classToBeTested	^ self timeClass! !!TimeTest methodsFor: 'Coverage' stamp: 'brp 1/30/2005 09:09'!selectorsToBeIgnored	 | deprecated private special primitives timing benchmarks |	deprecated := #().	private := #( #print24:on: #print24:showSeconds:on: ).	special := #( #< #= #new #printOn: #storeOn: ).	primitives := #( #primMillisecondClock #primSecondsClock ).	timing := #( #millisecondClockValue #milliseconds:since: #millisecondsSince: ).	benchmarks := #( #benchmarkMillisecondClock #benchmarkPrimitiveResponseDelay ). 	^ super selectorsToBeIgnored, deprecated, private, special, primitives, timing, benchmarks.! !!TimeTest methodsFor: 'Running' stamp: 'dtl 12/4/2016 12:17'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	localTimeZonePreferenceToRestore := DateAndTime automaticTimezone.	DateAndTime localTimeZone: TimeZone default.	time := self timeClass fromSeconds: 14567.		"4:02:47 am"	aTime := self timeClass readFrom: '12:34:56 pm' readStream.	timeWithNanos := self timeClass fromSeconds: 14567.42.! !!TimeTest methodsFor: 'Running' stamp: 'dtl 12/4/2016 12:18'!tearDown	DateAndTime localTimeZone: localTimeZoneToRestore.	DateAndTime automaticTimezone: localTimeZonePreferenceToRestore. ! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:33'!testAccessing	self		assert: time hours = 4;		assert: time minutes = 2;		assert: time seconds = 47;		assert: time asSeconds = 14567.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:35'!testArithmetic	| t1 t2 t3 |	t1 := time addSeconds: 70.		"4:03:57 am"	self		assert: t1 hours = 4;		assert: t1 minutes = 3;		assert: t1 seconds = 57.	t2 := t1 addTime: (self timeClass fromSeconds: (60*60*5)).	self		assert: t2 hours = 9;		assert: t2 minutes = 3;		assert: t2 seconds = 57.	t3 := t2 subtractTime: (self timeClass fromSeconds: (60*60*5) + 70).	self		assert: t3 = time.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:36'!testComparing	| t1 t2 t3 |	t1 := self timeClass fromSeconds: 14567.		"4:02:47 am"	t2 := self timeClass fromSeconds: 5000.		"1:23:20 am"	t3 := self timeClass fromSeconds: 80000.		"10:13:20 pm"	self		assert: time = t1;		assert: time hash = t1 hash;		assert: time = time copy.	self		deny: t1 < t2;		assert: t1 < t3.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:37'!testConverting	self		assert: time asSeconds = 14567.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:38'!testFromSeconds	| t |	t := self timeClass fromSeconds: 14567.	self		assert: t = time! !!TimeTest methodsFor: 'Tests' stamp: 'laza 8/28/2009 00:28'!testGeneralInquiries	| now d t dt epsilon |	"vm clocks seem to work differently across platforms, so an epsilon is required"	epsilon := 1. "second"	now  := self timeClass dateAndTimeNow.	self 		assert: now size = 2;		assert: (now last asSeconds - self timeClass now asSeconds) abs <= epsilon.	self should: [ self timeClass timeWords ] raise: MessageNotUnderstood.	d := '2 June 1973' asDate.	t := '4:02:47 am' asTime.	dt := self timeClass dateAndTimeFromSeconds: (2285280000 + 14567).	self		assert: dt = {d. t.}.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:44'!testNew		self assert: self timeClass new asSeconds = 0! !!TimeTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 22:27'!testPrinting	self			assert: time printString = '4:02:47 am';		assert: time intervalString =  '4 hours 2 minutes 47 seconds';		assert: time print24 = '04:02:47';		assert: time printMinutes = '4:02 am';		assert: time hhmm24 = '0402'.! !!TimeTest methodsFor: 'Tests' stamp: 'bf 7/8/2016 11:38'!testPrintingNanos	self			assert: timeWithNanos printString = '4:02:47.42 am';		assert: timeWithNanos intervalString =  '4 hours 2 minutes 47 seconds';		assert: timeWithNanos print24 = '04:02:47';		assert: timeWithNanos printMinutes = '4:02 am';		assert: timeWithNanos hhmm24 = '0402'.! !!TimeTest methodsFor: 'Tests' stamp: 'tfel 9/1/2009 07:14'!testReadFrom	| t1 t2 |	t1 := self timeClass readFrom: '4:02:47 am' readStream.	t2 := self timeClass readFrom: '4:02:47.000 am' readStream.	self		assert: time = t1;		assert: time = t2! !!TimeTest methodsFor: 'Tests' stamp: 'gk 8/31/2006 00:47'!testSqueakInquiries	| timewords totalseconds condensed corrected |	self assert: 		(self timeClass namesForTimes: #(2 10000023 10000026))			= #('January, 1901' 'April, 1901, 4/26/1901, 5:47 pm' 'April, 1901, 4/26/1901, 5:47 pm').	timewords := #(0.5 30 62 130 4000 10000 60000 86401) 		collect: [ :ss | self timeClass humanWordsForSecondsAgo: ss ].	self assert: 		timewords = #('a second ago' '30 seconds ago' 'a minute ago' '2 minutes ago' 			'an hour ago' '2 hours ago' '16 hours ago' 'yesterday').	totalseconds :=  self timeClass totalSeconds.	condensed := self timeClass condenseBunches: 		(#(20 400 401  20000 20200 20300 40000 45000  200000 201000 202000) 			collect: [:tt | totalseconds - tt]).	corrected := condensed collect: [ :e | totalseconds - e ].	self		assert: (corrected includesAllOf: #(20 400 401 20000 40000 45000 200000)).! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:47'!testStoring	self			assert: time storeString = '''4:02:47 am'' asTime';		assert: time = ('4:02:47 am' asTime).! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:36'!testAddSeconds	self assert: (aTime addSeconds: 1) = (Time readFromString: '12:34:57').	self assert: (aTime addSeconds: 60) = (Time readFromString: '12:35:56').		self assert: (aTime addSeconds: 3600) = (Time readFromString: '13:34:56').	self assert: (aTime addSeconds: 24*60*60) = (Time readFromString: '12:34:56').! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:36'!testAddTime	self assert: (aTime addTime: aTime) = (Time readFromString: '01:09:52').! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDate	self assert: (aTime asDate) = (Date current)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDateAndTime	self assert: (aTime asDateAndTime) = (DateAndTime current midnight + aTime)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDuration	self assert: (aTime asDuration) = (Duration days: 0 hours: 12 minutes: 34 seconds: 56)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsNanoSeconds	self assert: (aTime asNanoSeconds) = 45296000000000! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsSeconds	self assert: (aTime asSeconds) = 45296! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsTime	self assert: (aTime asTime) = aTime! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsTimeStamp	self assert: (aTime asTimeStamp) = (DateAndTime current midnight + aTime) asTimeStamp! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsWeek	self assert: aTime asWeek = (DateAndTime current midnight + aTime) asWeek! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsYear	self assert: aTime asYear = (DateAndTime current midnight + aTime) asYear! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testDuration	self assert: aTime duration = 0 seconds! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:37'!testEqual	self assert: aTime = (Time readFromString: '12:34:56').! !!TimeTest methodsFor: 'testing' stamp: 'eem 7/16/2014 15:38'!testHash	self assert: aTime hash = (Character instSize > 0 ifTrue: [607004] ifFalse: [101409191])! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHhmm24	self assert: aTime hhmm24 = '1234'! !!TimeTest methodsFor: 'testing' stamp: 'nk 3/30/2004 09:42'!testHour	self assert: aTime hour =  12.	self assert: aTime hour12 =  12.	self assert: aTime hour24 =  12.	self assert: aTime hours =  12.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHumanWordsForSecondsAgo	self assert: (Time humanWordsForSecondsAgo: 0.999999999)			= 'a second ago'.	self assert: (Time humanWordsForSecondsAgo: 44.99999999)			= '44.99999999 seconds ago'.	self assert: (Time humanWordsForSecondsAgo: 89.999999999)			= 'a minute ago'.	self assert: (Time humanWordsForSecondsAgo: 2699.999999999)			= '44 minutes ago'.	self assert: (Time humanWordsForSecondsAgo: 5399.999999999)			= 'an hour ago'.	self assert: (Time humanWordsForSecondsAgo: 64799.999999999)			= '17 hours ago'.	! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHumanWordsForSecondsAgoWithDays	self assert: (Time humanWordsForSecondsAgo: 18 * 60 * 60)					= 'yesterday'.	self assert: (Time humanWordsForSecondsAgo: 24 * 60 * 60)					= 'yesterday'.! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:35'!testLessThan	self assert: aTime < (Time readFromString: '12:34:57').! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testMeridianAbbreviation	self assert: aTime meridianAbbreviation =  'PM'.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testMinute	self assert: aTime minute =  34.	self assert: aTime minutes =  34! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testNanoSecond	self assert: aTime nanoSecond = 0	"Right now all times all seconds"! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24	self assert: aTime print24 = '12:34:56'! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:38'!testPrint24On	| referenceString printed |	referenceString := '12:34:56'.	printed := WriteStream on: ''.	aTime print24: true on: printed.	self assert: printed contents = referenceString! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:40'!testPrint24OnWithPM	| referenceString printed |	referenceString := '12:34:56 pm'.	printed := WriteStream on: ''.	aTime print24: false on: printed.	^ self assert: printed contents = referenceString! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:39'!testPrint24OnWithoutSeconds	| referenceString printed |	referenceString := '12:34'.	printed := WriteStream on: ''.	aTime print24: true showSeconds: false on: printed.	self assert: printed contents = referenceString! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrintMinutes	self assert: aTime printMinutes = '12:34 pm'! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:33'!testPrintOn	| referenceString printed |	referenceString := '12:34:56 pm'.	printed := WriteStream on: ''.	aTime printOn: printed.	self assert: printed contents = referenceString! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testSecond	self assert: aTime second =  56.	self assert: aTime seconds =  56! !!TimeTest methodsFor: 'testing' stamp: 'nice 11/1/2011 18:31'!testStoreOn	| referenceString stored |	referenceString := '''12:34:56 pm'' asTime'.	stored := WriteStream on: ''.	aTime storeOn: stored.	self assert: stored contents = referenceString! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testSubtractTime	self assert: (aTime subtractTime: aTime) = (Time readFrom: (ReadStream on: '00:00:00'))! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testTicks	self assert: aTime ticks = #(0 45296 0).	self assert: aTime  = (Time new ticks: #(0 45296 0))! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testTimeStamp	self assert: aTime = aTime asTimeStamp asTime! !!TimeTest methodsFor: 'Private' stamp: 'brp 7/27/2003 13:32'!timeClass	^ Time! !TestCase subclass: #TimespanDoSpanAYearTest	instanceVariableNames: 'aTimespan aDuration aDate'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!TimespanDoSpanAYearTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndTimeEpochTestCase for a complete list. tlk.My fixtures include a Timespan that crosses over a year boundary:aDate = December 25, 2004, midnightaDuration = 91 daysaTimeSpan= 91 days, starting December 25, 2004, midnight!!TimespanDoSpanAYearTest methodsFor: 'running' stamp: 'brp 9/26/2004 18:59'!setUp	aDate := DateAndTime year: 2004 month: 12 day: 25 hour: 0 minute: 0 second: 0.	aDuration := Duration days: 91 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.	aTimespan := Timespan starting: aDate duration: aDuration! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:55'!testMonthsDo	| monthArray |	monthArray := Array				with: (Month starting: (DateAndTime year: 2004 day: 355) duration: 31 days)				with: (Month starting: (DateAndTime year: 2005 day: 1) duration: 31 days)				with: (Month starting: (DateAndTime year: 2005 day: 32) duration: 29 days)				with: (Month starting: (DateAndTime year: 2005 day: 61) duration: 31 days).					self assert: aTimespan months = monthArray! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:55'!testNext	self assert: aTimespan next			= (Timespan					starting: (DateAndTime							year: 2005							month: 3							day: 26							hour: 0							minute: 0							second: 0)					duration: aDuration)! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 9/26/2004 19:06'!testWeeksDo	| weeks weekArray |	weeks := aTimespan weeks.	self assert: weeks size = ((aDuration days / 7.0) ceiling + 1).	weekArray := OrderedCollection new.	weekArray		addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 19) duration: 7 days);		addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 26) duration: 7 days).	2 to: 79 by: 7 do:		[ :i | weekArray				addLast: (Week starting: (DateAndTime year: 2005 day: i) duration: 7 days) ].	weekArray := weekArray asArray.	self assert: aTimespan weeks = weekArray! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'nk 3/30/2004 11:08'!testYearsDo	| yearArray |	yearArray := Array				with: (Year						starting: (DateAndTime								year: 2004								month: 12								day: 25)						duration: 366 days).	self assert: aTimespan years = yearArray! !TestCase subclass: #TimespanDoTest	instanceVariableNames: 'aTimespan aDuration aDate'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!TimespanDoTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndTimeEpochTestCase for a complete list.  tlk.My fixtures are:aDate = January 8, 2003, midnightaDuration = 91 daysaTimeSpan= 91 days, starting January 8, 2003, midnight!!TimespanDoTest methodsFor: 'running' stamp: 'cmm 8/6/2012 22:19'!setUp	aDate := DateAndTime				year: 2003				month: 01				day: 07				hour: 0				minute: 0				second: 0.	aDuration := Duration				days: 91				hours: 0				minutes: 0				seconds: 0				nanoSeconds: 0.	aTimespan := Timespan starting: aDate makeUTC duration: aDuration! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 18:00'!testDatesDo	| dateArray |	dateArray := OrderedCollection new.	7		to: 97		do: [:each | dateArray				addLast: (Date year: 2003 day: each)].	dateArray := dateArray asArray.	self assert: aTimespan dates = dateArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 16:36'!testDoWith	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan				starting: aDate				duration: 7 days).	self assert: count = 13! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 16:39'!testDoWithWhen	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: aDate duration: 7 days)		when: [:each | count < 5].	self assert: count = 5	! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 15:39'!testEveryDo	|count  duration |	count := 0.	duration := 7 days.	(aTimespan			every: duration			do: [:each | count := count + 1]).	self assert: count = 13			! !!TimespanDoTest methodsFor: 'testing' stamp: 'cmm 8/6/2012 22:23'!testMonthsDo	| monthArray |	monthArray := Array				with: (Month						starting: (DateAndTime year: 2003 day: 1 hour: 0 minute: 0 second: 0 offset: Month defaultOffset)						duration: 31 days)				with: (Month						starting: (DateAndTime year: 2003 day: 32 hour: 0 minute: 0 second: 0 offset: Month defaultOffset)						duration: 28 days)				with: (Month						starting: (DateAndTime year: 2003 day: 60 hour: 0 minute: 0 second: 0 offset: Month defaultOffset)						duration: 31 days)						with: (Month						starting: (DateAndTime year: 2003 day: 91 hour: 0 minute: 0 second: 0 offset: Month defaultOffset)						duration: 30 days).	self assert: aTimespan months = monthArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'cmm 8/6/2012 22:26'!testNext	self assert: aTimespan next 			= (Timespan					starting: (DateAndTime							year: 2003							month: 4							day: 8							hour: 0							minute: 0							second: 0 							offset: Timespan defaultOffset)					duration: aDuration)! !!TimespanDoTest methodsFor: 'testing' stamp: 'cmm 8/6/2012 22:22'!testWeeksDo	| weekArray |	weekArray := OrderedCollection new.	7		to: 98		by: 7		do: [:each | weekArray				addLast: (Week						starting: (DateAndTime year: 2003 day: each hour: 0 minute: 0 second: 0 offset: Week defaultOffset)						duration: 7 days)].	weekArray := weekArray asArray.	self assert: aTimespan weeks = weekArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'cmm 8/6/2012 22:24'!testYearsDo	| yearArray |	yearArray := Array				with: (Year						starting: (DateAndTime year: 2003 day: 7 hour: 0 minute: 0 second: 0 offset: Year defaultOffset)						duration: 365 days).	self assert: aTimespan years contents = yearArray contents! !ClassTestCase subclass: #TimespanTest	instanceVariableNames: 'timespan aTimespan anOverlappingTimespan anIncludedTimespan aDisjointTimespan aDay aWeek dec31 jan01 jan08 localTimeZoneToRestore anEqualTimeSpan localTimeZonePreferenceToRestore'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!TimespanTest methodsFor: 'Coverage' stamp: 'brp 9/15/2003 14:15'!classToBeTested	^ Timespan! !!TimespanTest methodsFor: 'Running' stamp: 'dtl 12/4/2016 12:18'!setUp	| jan01HereSomeWhereElseOnEarth |	localTimeZoneToRestore := DateAndTime localTimeZone.	localTimeZonePreferenceToRestore := DateAndTime automaticTimezone.	DateAndTime localTimeZone: TimeZone default.	"100 hours starting noon 22 March 2003"	timespan := Timespan starting:					(DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0)						duration: (Duration hours: 100).	dec31 := (DateAndTime year: 2004 month: 12 day: 31 hour: 0 minute: 0 second: 0).	jan01 := (DateAndTime year: 2005 month: 1 day: 1 hour: 0 minute: 0 second: 0).	jan08 := (DateAndTime year: 2005 month: 1 day: 8 hour: 0 minute: 0 second:0).	aDay := Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.	aWeek := Duration days: 7 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.	aTimespan := Timespan starting: jan01 duration: aWeek.	jan01HereSomeWhereElseOnEarth := DateAndTime new ticks: (jan01 + 3 hours) ticks offset: jan01 offset + 3 hours.	anEqualTimeSpan := Timespan starting: jan01HereSomeWhereElseOnEarth asUTC duration: aWeek.	anOverlappingTimespan := Timespan starting: dec31 duration: aWeek.	anIncludedTimespan := Timespan starting: jan01 duration: aDay.	aDisjointTimespan := Timespan starting: jan08 duration: aWeek.! !!TimespanTest methodsFor: 'Running' stamp: 'dtl 12/4/2016 12:19'!tearDown	DateAndTime localTimeZone: localTimeZoneToRestore.	DateAndTime automaticTimezone: localTimeZonePreferenceToRestore. 	timespan := nil! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 16:25'!testAccessing	self 		assert: (timespan start =				 (DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0));		assert: timespan duration = (Duration hours: 100);		assert: timespan month = 3;		assert: timespan monthName = 'March';		assert: timespan monthAbbreviation = 'Mar'		! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 9/15/2003 14:29'!testArithmetic	| ts1 ts2 d |	ts1 := timespan + 2 days.	ts2 := ts1 - 2 days.	d := ts1 - (DateAndTime year: 2003 month: 03 day: 20).	self 		assert: (ts1 start = 				 (DateAndTime year: 2003 month: 03 day: 24 hour: 12 minute: 0 second: 0));		assert: (ts1 duration = timespan duration);		assert: (ts2 start = timespan start);		assert: (ts2 duration = timespan duration).	self		assert: d = (Duration days: 4 hours: 12 minutes: 0 seconds: 0)! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:43'!testInclusion	| t1 t2 t3 t4 |	t1 := timespan start.	t2 := timespan start + (timespan duration / 2).	t3 := timespan end.	t4 := timespan start + (timespan duration).	self 		assert: (timespan includes: t1);		assert: (timespan includes: t2);		assert: (timespan includes: t3)";		deny: (timespan includes: t4).	self		assert: (timespan includes: (t1 to: t2));		assert: (timespan includes: (t1 to: t4));		deny: (timespan includes: (Timespan starting: t2 duration: (timespan duration * 2))).	self 		assert: (timespan includesAllOf: { t1. t2. t3 } );		deny: (timespan includesAllOf: { t1. t2. t3. t4} ).	self 		assert: (timespan includesAnyOf: { t1. t2. t3 } );		deny: (timespan includesAnyOf: { t4 } )."! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 16:49'!testUnion	| union |	union := timespan union: timespan.		self 		assert: (union start = timespan start);		assert: (union duration = timespan duration)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDate	self assert: aTimespan asDate =   jan01 asDate.	"MessageNotUnderstood: Date class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDateAndTime	self assert: aTimespan asDateAndTime =   jan01.	"MessageNotUnderstood: Date class>>starting:"	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDuration	self assert: aTimespan asDuration =  aWeek.		! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsMonth	self assert: aTimespan asMonth =   jan01 asMonth.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsTime	self assert: aTimespan asTime =  jan01 asTime	"MessageNotUnderstood: Time class>>seconds:nanoSeconds:" ! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsTimeStamp	self assert: aTimespan asTimeStamp =  ((TimeStamp readFrom: '1-01-2005 0:00 am' readStream) offset: 0 hours).! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsWeek	self assert: aTimespan asWeek =   jan01 asWeek.	"DateAndTime new asWeek	 MessageNotUnderstood: Week class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsYear	self assert: aTimespan asYear =   jan01 asYear.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 9/23/2004 09:58'!testClockPrecisionDuration	| ts |	ts := Timespan starting: Date today duration: DateAndTime clockPrecision.	self		assert: ts start = ts end! !!TimespanTest methodsFor: 'testing' stamp: 'nk 3/30/2004 09:26'!testCurrent	self assert: (Timespan starting: DateAndTime current)			<= Timespan current.	self assert:  Timespan current			<= (Timespan starting: DateAndTime current)! !!TimespanTest methodsFor: 'testing' stamp: 'cmm 2/18/2016 15:11'!testDateToday	self assert: Date today start offset isZero! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDay	self assert: aTimespan day =   jan01 day! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfMonth	self assert: aTimespan dayOfMonth  = 1.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfWeek	self assert: aTimespan  dayOfWeek  = 7.	self assert: aTimespan  dayOfWeekName = 'Saturday'.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfYear	self assert: aTimespan  dayOfYear  = 1.	"MessageNotUnderstood: UndefinedObject>>year:, Undefined object is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysInMonth	self assert: aTimespan  daysInMonth  = 31.	"MessageNotUnderstood: Month class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysInYear	self assert: aTimespan  daysInYear  = 365.	"MessageNotUnderstood: UndefinedObject>>starting:  UndefinedObject is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysLeftInYear	self assert: aTimespan  daysLeftInYear  = 364.	"MessageNotUnderstood: UndefinedObject>>starting:  UndefinedObject is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDoWith	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: jan01 duration: aDay).	self assert: count = 7! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDoWithWhen	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: jan01 duration: aDay)		when: [:each | count < 5].	self assert: count = 5! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDuration	self assert: aTimespan duration  = aWeek.	aTimespan duration: aDay.	self assert: aTimespan duration =  aDay.! !!TimespanTest methodsFor: 'testing' stamp: 'klc 9/10/2010 17:11'!testEnd	self assert: aTimespan end + (Duration  nanoSeconds:1)  =  aDisjointTimespan start.	self assert: aTimespan end = (DateAndTime year: 2005 month: 1 day: 7 hour: 23 minute: 59 second: 59 nanoSecond: 999999999 offset: 0 hours)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testEveryDo	| count duration |	count := 0.	duration := 7 days.	aTimespan		every: duration		do: [:each | count := count + 1].	self assert: count = 1! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testFirstDayOfMonth	self assert: aTimespan firstDayOfMonth =   1. 	self assert: aDisjointTimespan firstDayOfMonth =   1! !!TimespanTest methodsFor: 'testing' stamp: 'nice 5/10/2012 23:50'!testHash	self assert: (aTimespan = anEqualTimeSpan) ==> [aTimespan hash = anEqualTimeSpan hash]! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludes	self assert: (aTimespan includes: jan01).	self deny: (aTimespan includes: jan08)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludesAllOf	self assert: (aTimespan includesAllOf: (Bag with: jan01)).	self deny: (aTimespan includesAllOf: (Bag with: jan01 with: jan08))! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludesAnyOf	self deny: (aTimespan includesAnyOf: (Bag with: dec31)).	self assert: (aTimespan includesAnyOf: (Bag with: jan01 with: jan08))	"Error is due to bug in Timespan includesAnyOf: aCollection "	"Answer whether any element of aCollection is included in the receiver"	"aCollection do: [ :elem | (self includes: elem) ifTrue: [^ true]].Shouldn't this return false if none are included?"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithDisjoint	self assert: (aTimespan intersection: aDisjointTimespan) isNil.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithIncluded	self assert: (aTimespan intersection: anIncludedTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 0 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= anIncludedTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithOverlapping	self assert: (aTimespan intersection: anOverlappingTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 5 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).		! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithSelf	self assert: (aTimespan intersection: aTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 6 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= aTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithSeparate	self assert: (aTimespan intersection: aDisjointTimespan) isNil.	self deny: (aTimespan intersection: anOverlappingTimespan) isNil.	self assert: (aTimespan intersection: anIncludedTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 0 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= anIncludedTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIsLeapYear	"self assert: anOverlappingTimespan isLeapYear."	"not sure why this fails"	self deny: aTimespan isLeapYear! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testJulianDayNumber	self assert: aTimespan julianDayNumber =  (jan01 julianDayNumber).! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testLessThan	self assert: aTimespan  < aDisjointTimespan.	self deny: anIncludedTimespan < aTimespan	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMinusADateAndTime	"It appears that subtracting a date from a Timespan gives you a duration = to the difference between the start of the timespan and the date "	self assert: aTimespan - dec31 =  aDay.	self assert: aDisjointTimespan - jan01 =  aWeek.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMinusADuration	"It appears that subtracting a duration from a Timespan gives you a Timespan shifted by the duration"	self assert: aTimespan - aDay =  anOverlappingTimespan.	self assert: aDisjointTimespan - aWeek =  aTimespan.	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMonth	self assert: aTimespan month  = 1.	self assert: aTimespan monthName = 'January'.	self assert: aTimespan monthIndex = 1.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testNew	self assert: Timespan new = (Timespan starting: '01-01-1901' asDate)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testNext	self assert: aTimespan next = aDisjointTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testPlus	self assert: aTimespan + aWeek = aDisjointTimespan.	self assert: anOverlappingTimespan + aDay = aTimespan.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testPrevious	self assert: aTimespan  = aDisjointTimespan previous.	self assert: aTimespan next previous = aTimespan ! !!TimespanTest methodsFor: 'testing' stamp: 'nice 2/23/2013 19:39'!testPrintOn	| ref ws |	ref := 'a Timespan(2005-01-01T00:00:00+00:00D7:00:00:00)'.	ws := '' writeStream.	aTimespan printOn: ws.	self assert: ws contents = ref! !!TimespanTest methodsFor: 'testing' stamp: 'cmm 2/18/2016 17:30'!testRematerializedDateComparison	"Tests whether comparison semantics are affected by serialization / rematerialization."	| isItTrue date refStream rwstream | date := Date today.	isItTrue := DateAndTime now asDate = date.	self assert: (date = DateAndTime now asDate) = isItTrue.	self assert: (DateAndTime now asDate = date) = isItTrue.	rwstream := RWBinaryOrTextStream on: ByteArray new.	refStream := ReferenceStream on: rwstream..	refStream nextPut: date; close.	rwstream position: 0.	refStream := ReferenceStream on: rwstream.	date := refStream next.	refStream close.	self assert: (date = DateAndTime now asDate) = isItTrue.	self assert: (DateAndTime now asDate = date) = isItTrue.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testStart	self assert: aTimespan start =   jan01.	aTimespan start: jan08.	self assert: aTimespan start =   jan08.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testStartingEnding	self assert: aTimespan  = (Timespan starting: jan01 ending: jan08)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testTo	self assert: (anIncludedTimespan to: jan08) = aTimespan ! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithDisjoint	self assert: (aTimespan union: aDisjointTimespan)  = 		(Timespan starting: jan01 duration: (14 days)).				! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithIncluded	self 		assert: (aTimespan union: anIncludedTimespan) = aTimespan 	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithOverlapping	self 		assert: (aTimespan union: anOverlappingTimespan)  = 				(Timespan starting: dec31 duration: (8 days))! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithSelf	self assert: (aTimespan union: aTimespan) = aTimespan	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithSeparate	self 		assert: (anOverlappingTimespan union: aDisjointTimespan) = 			(Timespan 				starting: anOverlappingTimespan start				ending:  (aDisjointTimespan end + DateAndTime clockPrecision))			! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testWorkDatesDo	| count |	count := 0.	aTimespan		workDatesDo: [:each | count := count + 1].	self assert: count = 5! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testYear	self assert: aTimespan year = 2005.	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 9/23/2004 09:57'!testZeroDuration	| ts |	ts := Timespan starting: Date today duration: Duration zero.	self		assert: ts start = ts end! !ClassTestCase subclass: #WeekTest	instanceVariableNames: 'week restoredStartDay'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!WeekTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 12:42'!classToBeTested	^ Week! !!WeekTest methodsFor: 'Coverage' stamp: 'brp 1/30/2005 09:21'!selectorsToBeIgnored	| deprecated private special |	deprecated := #().	private := #( #printOn: ).	special := #( #next #do: ).	^ super selectorsToBeIgnored, deprecated, private, special.! !!WeekTest methodsFor: 'Running' stamp: 'brp 9/26/2004 18:52'!setUp	"June 1998, 5th week"	super setUp.	restoredStartDay := Week startDay.	Week startDay: #Sunday.	week := Week starting: '4 July 1998' asDate! !!WeekTest methodsFor: 'Running' stamp: 'brp 9/26/2004 18:53'!tearDown	super tearDown.	Week startDay: restoredStartDay.	week := nil.! !!WeekTest methodsFor: 'Tests' stamp: 'it 7/14/2009 19:47'!testDayNames	self assert: (Week dayNames) = #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).! !!WeekTest methodsFor: 'Tests' stamp: 'brp 1/30/2005 09:32'!testEnumerating	| days |	days := OrderedCollection new.	0 to: 6 do: [ :i | days add: ('28 June 1998' asDate addDays: i) ].	week datesDo: [ :d | days remove: d ].		self assert: days isEmpty.! !!WeekTest methodsFor: 'Tests' stamp: 'it 7/14/2009 19:52'!testIndexOfDay	| days |	days := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).		days withIndexDo: [:item :index | self assert: (Week indexOfDay: item) = index].		"This should probably raise an error rather than returning 0."	self assert: (Week indexOfDay: 0) = 0.	self assert: (Week indexOfDay: 1) = 0.	self assert: (Week indexOfDay: 7) = 0.	self assert: (Week indexOfDay: 8) = 0.	self assert: (Week indexOfDay: #Sunnyday) = 0.! !!WeekTest methodsFor: 'Tests' stamp: 'brp 1/30/2005 09:30'!testInquiries	self		assert: week start asDate = '28 June 1998' asDate;		assert: week end asDate = '4 July 1998' asDate;		assert: week index = 5;		assert: week duration = (7 days).! !!WeekTest methodsFor: 'Tests' stamp: 'it 7/14/2009 19:46'!testNameOfDay	| days |	days := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).		days withIndexDo: [:item :index | self assert: (Week nameOfDay: index) = item].		self should: [Week nameOfDay: 0] raise: TestResult error.	self should: [Week nameOfDay: 8] raise: TestResult error.	self should: [Week nameOfDay: #Sunday] raise: TestResult error.! !!WeekTest methodsFor: 'Tests' stamp: 'nk 7/30/2004 17:52'!testPreviousNext	self		assert: week next = (Week starting: '6 July 1998' asDate);		assert: week previous = (Week starting:  '22 June 1998' asDate)! !TestCase subclass: #YearMonthWeekTest	instanceVariableNames: 'restoredStartDay restoredTimeZone localTimeZonePreferenceToRestore'	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!YearMonthWeekTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndEpochTestCase for a complete list.  tlk.I have no fixtures but do make sure to restore anything I change.!!YearMonthWeekTest methodsFor: 'running' stamp: 'dtl 2/4/2017 21:24'!setUp	restoredStartDay := Week startDay.	restoredTimeZone := DateAndTime localTimeZone.	localTimeZonePreferenceToRestore := DateAndTime automaticTimezone.	Week startDay: #Sunday.	DateAndTime localTimeZone: (TimeZone timeZones detect: [:tz | tz abbreviation = 'GMT']).! !!YearMonthWeekTest methodsFor: 'running' stamp: 'dtl 12/4/2016 12:20'!tearDown	Week startDay: restoredStartDay.	DateAndTime localTimeZone: restoredTimeZone.	DateAndTime automaticTimezone: localTimeZonePreferenceToRestore.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:51'!testDaysInMonth	self assert: (Month daysInMonth: 2 forYear: 2000) = 29.	self assert: (Month daysInMonth: 2 forYear: 2001) = 28.	self assert: (Month  daysInMonth: 2 forYear: 2004) = 29.	self assert: (Month  daysInMonth: 2 forYear: 2100) = 28.		self assert: (Month  daysInMonth: 'January' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'February' forYear: 2003) = 28.	self assert: (Month  daysInMonth: 'March' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'April' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'May' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'June' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'July' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'August' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'September' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'October' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'November' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'December' forYear: 2003) = 31.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:37'!testDaysInYear	self assert: (Year daysInYear: 2000) = 366.	self assert: (Year daysInYear: 2001) = 365.	self assert: (Year daysInYear: 2004) = 366.	self assert: (Year daysInYear: 2100) = 365.	self assert: (Year daysInYear: 2003) = 365.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 13:37'!testIndexOfDay	self assert: (Week indexOfDay: 'Friday') = 6.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:33'!testIsLeapYear	self assert: (Year isLeapYear: 2000).	self deny: (Year isLeapYear: 2001).	self assert: (Year isLeapYear: 2004).	self deny: (Year isLeapYear: 2100).	self deny: (Year isLeapYear: 2002).! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'nice 2/23/2013 19:37'!testMonthPrintOn	| aMonth ws |	aMonth := Month starting: DateAndTime new duration: 31 days.	ws := '' writeStream.	aMonth printOn: ws.	self assert: ws contents = 'January 1901'.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 13:34'!testStartDay	Week startDay: 'Wednesday'.	self assert: Week startDay = 'Wednesday'.	Week startDay: 'Thursday'.	self assert: Week startDay = 'Thursday'.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'brp 9/26/2004 18:49'!testWeekPrintOn	| aWeek cs rw |	aWeek := Week starting: (DateAndTime year: 1900 month: 12 day: 31).	cs := 'a Week starting: 1900-12-30T00:00:00+00:00'.	rw := WriteStream on: ''.	aWeek printOn: rw.	self assert: rw contents = cs! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'nice 2/23/2013 19:34'!testYearPrintOn	| aYear ws |	aYear := Year starting: DateAndTime new duration: 365 days.	ws := '' writeStream.	aYear printOn: ws.	self assert: ws contents = 'a Year (1901)'.! !ClassTestCase subclass: #YearTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Chronology-Tests'!!YearTest methodsFor: 'Coverage' stamp: 'brp 9/11/2003 14:31'!classToBeTested	^ Year! !!YearTest methodsFor: 'Tests' stamp: 'cmm 2/3/2012 18:36'!testCurrent	self assert:		Year current start =			((DateAndTime				year: DateAndTime now year				month: 1				day: 1) offset: Year defaultOffset)! !!YearTest methodsFor: 'Tests' stamp: 'brp 6/16/2008 08:37'!testPreviousInLeapYear	| leap |	leap := Year year: 2008.	self assert: leap isLeapYear. 	self assert: (Year year: (leap year - 1)) = leap previous ! !